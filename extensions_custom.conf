[from-internal-custom]
; -------------------------
; ACCESS SHORTCUTS FOR *222#
; Matches *222#... with extra tokens and routes automatically
; Must be placed BEFORE the original _*222# entry
; -------------------------
exten => _*222#.,1,NoOp(Shortcut handler for ${EXTEN})
 same => n,Answer()
 same => n,Set(CALLER=${CALLERID(num)})
 same => n,Set(FULL_EXTEN=${EXTEN})                     ; ejemplo: *222#123*2*param1*param2#

 ; EXTRAER todo lo que viene después del primer "#"
 same => n,Set(P2=${CUT(FULL_EXTEN,#,2)})
 same => n,NoOp(DEBUG: FULL_EXTEN='${FULL_EXTEN}' P2='${P2}')

 ; si nothing after the first # => fallback to normal menu (let main handler run)
 same => n,GotoIf($["${P2}" = ""]?fallback_menu)

 ; parse password = primer token en P2 separado por "*"
 same => n,Set(PASS=${CUT(P2,*,1)})
 same => n,Set(OPT=${CUT(P2,*,2)})                   ; puede quedar vacio

 ; parámetros adicionales: Z1..Zn (P1, P2A, P3, ...)
 same => n,Set(P1=${CUT(P2,*,3)})
 same => n,Set(P2A=${CUT(P2,*,4)})
 same => n,Set(P3=${CUT(P2,*,5)})
 same => n,Set(P4=${CUT(P2,*,6)})
 same => n,Set(P5=${CUT(P2,*,7)})

;parametros PARA BYPASS CONTRASENIA
 same => n, Set(PASWORD=${CUT(EXTEN,#,2)})
 same => n, Set(I=${CUT(EXTEN,#,3)})
 same => n, Set(CALLER_CLIENT=${CUT(EXTEN,#,4)})
 same => n,ExecIf($[${LEN(${PASWORD})} = 5]?Macro(bypass-password,${PASWORD},${I},${CALLER_CLIENT}):Goto(auth_fail))


 same => n,NoOp(DEBUG: PASS='${PASS}' OPT='${OPT}' P1='${P1}' P2A='${P2A}' P3='${P3}' P4='${P4}' P5='${P5}' I='${I}' PASSWORD='${PASWORD}' CALLER='${CALLER_CLIENT}')
 
 ; comprobar bloqueo antes de autenticar
 same => n,Set(BLOQUEADO=${DB(reminders/${CALLER}/blocked)})
 same => n,GotoIf($["${BLOQUEADO}" = "1"]?blocked_service)

 ; validar contraseña almacenada para este caller
 same => n,Set(STORED_PASS=${DB(reminders/${CALLER}/password)})
 ; si no hay pass configurada, FALLBACK a flujo interactivo (salta al handler normal)
 same => n,GotoIf($["${STORED_PASS}" = ""]?fallback_menu)

 ; comparar password rápido (sin reproducir audios)
 same => n,GotoIf($["${PASS}" = "${STORED_PASS}"]?auth_ok:auth_fail)

 same => n(auth_fail),NoOp(Shortcut auth failed for ${CALLER} (PASS=${PASS}))
 same => n,Playback(custom-service-blocked)
 same => n,Hangup()

 same => n(auth_ok),NoOp(Shortcut auth OK for ${CALLER} -> OPT=${OPT})
 same => n,Set(PASSWORD_VALID=1)

 same => n,GotoIf($["${OPT}" = ""]?menu_principal_shortcut)

 ; ROUTEO DE OPCIONES DIRECTAS (1..5)
 same => n,GotoIf($["${OPT}" = "1"]?do_list)
 same => n,GotoIf($["${OPT}" = "2"]?do_create)
 same => n,GotoIf($["${OPT}" = "3"]?do_modify)
 same => n,GotoIf($["${OPT}" = "4"]?do_delete)
 same => n,GotoIf($["${OPT}" = "5"]?do_list_repeated)

 same => n,Playback(custom-invalid-option)
 same => n,Hangup()

; -------------- HANDLERS --------------
same => n(do_list),NoOp(Shortcut: listar recordatorios para ${CALLER})
 same => n,Macro(list-reminders,${CALLER})
 same => n,Hangup()

; OPT=2 -> crear recordatorio DIRECTO con parámetros:
; P1=date(AAAAMMDD), P2A=time(HHMM), P3=typeNum(1..4), P4=offsetChoice(1->15,2->30,3->1440), P5=repeats
same => n(do_create),NoOp(Shortcut: crear recordatorio directo para ${CALLER})
 same => n,Set(DATE=${P1})
 same => n,Set(TIME=${P2A})
 same => n,Set(TYPE_NUM=${P3})
 same => n,Set(OFFSET_CHOICE=${P4})
 same => n,Set(REPEATS=${P5})
 ; Validaciones básicas
 same => n,GotoIf($["${DATE}" = ""]?create_param_missing)
 same => n,GotoIf($["${TIME}" = ""]?create_param_missing)
 same => n,GotoIf($["${TYPE_NUM}" = ""]?create_param_missing)
 same => n,GotoIf($["${OFFSET_CHOICE}" = ""]?create_param_missing)
 same => n,GotoIf($["${REPEATS}" = ""]?create_param_missing)
 ; Llamar al macro que graba y schedulea usando parámetros
 same => n,Macro(create-reminder-directaccess,${CALLER},${DATE},${TIME},${TYPE_NUM},${OFFSET_CHOICE},${REPEATS})
 same => n,Hangup()
 same => n(create_param_missing),Playback(custom-invalid-option)
 same => n,Hangup()
; OPT=3 -> modificar recordatorio DIRECTO:
; P1 = ID, P2A = NEW_DATE, P3 = NEW_TIME, P4 = NEW_TYPE_NUM, P5 = NEW_OFFSETCHOICE, P6 = NEW_REPEATS
same => n(do_modify),NoOp(Shortcut: modificar reminder directo para ${CALLER})
 same => n,Set(MODID=${P1})
 same => n,Set(NEW_DATE=${P2A})
 same => n,Set(NEW_TIME=${P3})
 same => n,Set(NEW_TYPE_NUM=${P4})
 same => n,Set(P5=${CUT(P2,*,7)})
 same => n,Set(NEW_OFF_CHOICE=${P5})
 same => n,Set(P6=${CUT(P2,*,8)})
 same => n,Set(NEW_REPEATS=${P6})
 ; Validaciones básicas
 same => n,GotoIf($["${MODID}" = "" ]?mod_param_missing)
 same => n,GotoIf($["${NEW_DATE}" = "" ]?mod_param_missing)
 same => n,GotoIf($["${NEW_TIME}" = "" ]?mod_param_missing)
 same => n,GotoIf($["${NEW_TYPE_NUM}" = "" ]?mod_param_missing)
 same => n,GotoIf($["${NEW_OFF_CHOICE}" = "" ]?mod_param_missing)
 same => n,GotoIf($["${NEW_REPEATS}" = "" ]?mod_param_missing)
 ; Invocar macro que aplica la modificación (incluye regrabación opcional)
 same => n,Macro(modify-reminder-directaccess,${CALLER},${MODID},${NEW_DATE},${NEW_TIME},${NEW_TYPE_NUM},${NEW_OFF_CHOICE},${NEW_REPEATS})
 same => n,Hangup()
 same => n(mod_param_missing),Playback(custom-invalid-option)
 same => n,Hangup()


; OPT=4 -> borrar directo: P1 = ID
same => n(do_delete),NoOp(Shortcut: borrar directo para ${CALLER})
 same => n,Set(DELID=${P1})
 same => n,GotoIf($["${DELID}" = ""]?del_param_missing)
 ; llamar macro que borra con seguridad (usa file_base previamente recuperado dentro del macro)
 same => n,Macro(delete-reminder-directaccess,${CALLER},${DELID})
 same => n,Hangup()
 same => n(del_param_missing),Playback(custom-invalid-option)
 same => n,Hangup()

same => n(do_list_repeated),NoOp(Shortcut: listar recordatorios repetidos para ${CALLER})
 same => n,Macro(list-repeated-reminders,${CALLER})
 same => n,Hangup()

 ; bloqueo
 same => n(blocked_service),NoOp(Servicio bloqueado para ${CALLER})
 same => n,Playback(custom-service-blocked)
 same => n,Hangup()

 ; salto al menú normal (sin shortcut)
 same => n(fallback_menu),NoOp(Fallback to interactive *222# flow)
 same => n,Goto(from-internal-custom,*222#,1)

 ; Si hubo entrada solo password, ir al menú principal del handler normal
 same => n(menu_principal_shortcut),NoOp(Acceso directo -> Menu principal)
 same => n,Set(PASSWORD_VALID=1)
 same => n,Background(custom-enter-menu)
 same => n,WaitExten(6)
 same => n,Playback(custom-vm-goodbye)
 same => n,Hangup()


; ==================== SERVICIO PRINCIPAL *222# ====================
exten => _*222#,1,NoOp(=== Iniciando servicio *222# ===)
 same => n,Answer()
 same => n,Set(NUMERO_ORIGEN=${CALLERID(num)})
 same => n,GotoIf($["${NUMERO_ORIGEN}" = ""]?error_no_caller)
 
 ; Verificar si el servicio está bloqueado para este usuario
 same => n,Set(BLOQUEADO=${DB(reminders/${NUMERO_ORIGEN}/blocked)})
 same => n,GotoIf($["${BLOQUEADO}" = "1"]?servicio_bloqueado)
 
 ; Verificar si ya existe contraseña
 same => n,Set(PASSWORD_STORED=${DB(reminders/${NUMERO_ORIGEN}/password)})
 same => n,GotoIf($["${PASSWORD_STORED}" = ""]?primera_vez:validar_password)

same => n(primera_vez),Macro(create-password,${NUMERO_ORIGEN})
 same => n,Goto(menu_principal)


same => n(validar_password),Set(bypass=${DB(reminders/${NUMERO_ORIGEN}/bypass)})
 same => n,GotoIf($["${bypass}" = "true"]?menu_principal:validate_password)
 same => n(validate_password), Macro(validate-password,${NUMERO_ORIGEN})
 same => n,GotoIf($["${PASSWORD_VALID}" = "1"]?menu_principal:fin)

same => n(servicio_bloqueado),NoOp(Servicio bloqueado para ${NUMERO_ORIGEN})
 same => n,Playback(custom-service-blocked)
 same => n,Hangup()

same => n(menu_principal),NoOp(=== MENU PRINCIPAL ===)
 same => n,Background(custom-enter-menu)
 same => n,WaitExten(6)
 same => n,Playback(custom-vm-goodbye)
 same => n,Hangup()

same => n(error_no_caller),Playback(custom-system-error)
 same => n,Hangup()

same => n(fin),Hangup()

; --- HANDLERS DEL MENÚ ---
exten => 1,1,NoOp(Usuario pulsó 1 -> Listar Fechas Especiales)
 same => n,Macro(list-reminders,${CALLERID(num)})
 same => n,Hangup()

exten => 2,1,NoOp(Usuario pulsó 2 -> iniciar crear de recordatorio)
 same => n,Macro(collect-reminder)
 same => n,Hangup()

exten => 3,1,NoOp(Usuario pulsó 3 -> iniciar modificacion de recordatorio)
 same => n,Macro(modify-reminder,${CALLERID(num)})
 same => n,Hangup()


exten => 4,1,NoOp(Usuario pulsó 4 -> Borrar fecha especial)
 same => n,Macro(delete-reminder,${CALLERID(num)})
 same => n,Hangup()

exten => 5,1,NoOp(Usuario pulsó 5 -> Listar recordadas múltiples veces)
 same => n,Macro(list-repeated-reminders,${CALLERID(num)})
 same => n,Hangup()


; ==================== SERVICIO DE DESBLOQUEO #222# ====================
exten => _#222#,1,NoOp(=== Servicio de desbloqueo #222# ===)
 same => n,Answer()
 same => n,Set(NUMERO_ORIGEN=${CALLERID(num)})
 same => n,GotoIf($["${NUMERO_ORIGEN}" = ""]?error_desbloqueo)
 same => n,Macro(unlock-and-change,${NUMERO_ORIGEN})
 same => n,Hangup()

same => n(error_desbloqueo),Playback(custom-system-error)
 same => n,Hangup()


; ==================== SERVICIO DE RESET *999# ====================
exten => _*999#,1,NoOp(=== Servicio de RESET COMPLETO *999# ===)
 same => n,Answer()
 same => n,Set(NUMERO_ORIGEN=${CALLERID(num)})
 same => n,GotoIf($["${NUMERO_ORIGEN}" = ""]?error_reset)
 same => n,Macro(reset-all-data,${NUMERO_ORIGEN})
 same => n,Hangup()

same => n(error_reset),Playback(custom-system-error)
 same => n,Hangup()


[macro-create-password]
exten => s,1,NoOp(=== Macro create-password iniciado para ${ARG1} ===)
 same => n,Playback(custom-welcome)
 same => n,Playback(custom-create-password)
 same => n,Playback(beep)
 same => n,Read(NUEVA_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?s,1)
 same => n,GotoIf($[${LEN(${NUEVA_PASSWORD})} = 5]?confirmar:invalid)

same => n(invalid),Playback(custom-invalid-password)
 same => n,Goto(s,1)

same => n(confirmar),NoOp(Confirmando contraseña: ${NUEVA_PASSWORD})
 same => n,Playback(custom-confirm-password)
 same => n,Playback(beep)
 same => n,Read(CONFIRMAR_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${NUEVA_PASSWORD}" = "${CONFIRMAR_PASSWORD}"]?guardar:no_match)

same => n(no_match),Playback(custom-passwords-dont-match)
 same => n,Goto(s,1)

same => n(guardar),NoOp(Guardando contraseña para ${ARG1})
 same => n,Set(DB(reminders/${ARG1}/password)=${NUEVA_PASSWORD})
 same => n,Set(DB(reminders/${ARG1}/blocked)=0)
 same => n,Set(DB(reminders/${ARG1}/fail_count)=0)
 same => n,Playback(custom-password-created)
 same => n,MacroExit()

same => n(abort),Hangup()


[macro-validate-password]
exten => s,1,NoOp(=== Macro validate-password iniciado para ${ARG1} ===)
 same => n,Set(PASSWORD_STORED=${DB(reminders/${ARG1}/password)})
 same => n,Set(FAIL_COUNT=${DB(reminders/${ARG1}/fail_count)})
 same => n,ExecIf($["${FAIL_COUNT}" = ""]?Set(FAIL_COUNT=0))
 same => n,Set(INTENTOS_RESTANTES=$[3 - ${FAIL_COUNT}])
 
 same => n(solicitar),Playback(custom-enter-password)
 same => n,Playback(beep)
 same => n,Read(PASSWORD_INPUT,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?solicitar)
 
 same => n,GotoIf($["${PASSWORD_INPUT}" = "${PASSWORD_STORED}"]?correcto:incorrecto)

same => n(correcto),NoOp(Contraseña correcta)
 same => n,Set(DB(reminders/${ARG1}/fail_count)=0)
 same => n,Playback(custom-access-granted)
 same => n,Set(PASSWORD_VALID=1)
 same => n,MacroExit()

same => n(incorrecto),NoOp(Contraseña incorrecta - Intento: ${FAIL_COUNT})
 same => n,Set(FAIL_COUNT=$[${FAIL_COUNT} + 1])
 same => n,Set(DB(reminders/${ARG1}/fail_count)=${FAIL_COUNT})
 same => n,Set(INTENTOS_RESTANTES=$[3 - ${FAIL_COUNT}])
 
 same => n,GotoIf($[${FAIL_COUNT} >= 3]?bloquear)
 
 same => n,Playback(custom-incorrect-password)
 same => n,SayNumber(${INTENTOS_RESTANTES})
 same => n,Playback(custom-attempts-remaining)
 same => n,Goto(solicitar)

same => n(bloquear),NoOp(Bloqueando servicio por intentos fallidos)
 same => n,Set(DB(reminders/${ARG1}/blocked)=1)
 same => n,Playback(custom-service-blocked)
 same => n,Set(PASSWORD_VALID=0)
 same => n,MacroExit()

same => n(abort),Set(PASSWORD_VALID=0)
 same => n,MacroExit()


[macro-unlock-and-change]
exten => s,1,NoOp(=== Macro unlock-and-change iniciado para ${ARG1} ===)
 same => n,Set(PASSWORD_STORED=${DB(reminders/${ARG1}/password)})
 same => n,GotoIf($["${PASSWORD_STORED}" = ""]?no_password)
 
 ; Solicitar contraseña actual
 same => n,Playback(custom-unlock-password)
 same => n,Playback(beep)
 same => n,Read(PASSWORD_INPUT,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${PASSWORD_INPUT}" = "${PASSWORD_STORED}"]?correcto:incorrecto)

same => n(correcto),NoOp(Contraseña correcta - Desbloqueando)
 same => n,Set(DB(reminders/${ARG1}/blocked)=0)
 same => n,Set(DB(reminders/${ARG1}/fail_count)=0)
 same => n,Playback(custom-service-unlocked)
 same => n,Goto(menu_cambio)

same => n(incorrecto),Playback(custom-incorrect-password)
 same => n,Playback(custom-unlock-failed)
 same => n,MacroExit()

same => n(no_password),Playback(custom-no-password-set)
 same => n,MacroExit()

; ===== Menú para cambiar contraseña (robusto sin WaitExten) =====
same => n(menu_cambio),Playback(custom-change-password-prompt)   ; "1 cambiar, 2 salir"
 same => n,Playback(beep)
 same => n,Read(MENUOPT,,1,,3,6)   ; 1 dígito, 3 intentos, 6s timeout
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?menu_timeout)
 same => n,GotoIf($["${MENUOPT}" = "1"]?do_change)
 same => n,GotoIf($["${MENUOPT}" = "2"]?fin_cambio)
 same => n,Playback(invalid)
 same => n,Goto(menu_cambio)

same => n(menu_timeout),Playback(custom-vm-goodbye)
 same => n,MacroExit()

; ===== Flujo de cambio de contraseña =====
same => n(do_change),NoOp(Usuario eligió cambiar contraseña)
 same => n,Set(NUMERO_ORIGEN=${ARG1})
 same => n,Playback(custom-new-password)   ; "Ingrese nueva contraseña de 5 dígitos"
 same => n,Playback(beep)
 same => n,Read(NUEVA_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?fin_cambio)
 same => n,GotoIf($[${LEN(${NUEVA_PASSWORD})} = 5]?confirmar_nueva:invalid_nueva)

same => n(invalid_nueva),Playback(custom-invalid-password)
 same => n,Goto(do_change)

same => n(confirmar_nueva),Playback(custom-confirm-password)
 same => n,Playback(beep)
 same => n,Read(CONFIRMAR_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${NUEVA_PASSWORD}" = "${CONFIRMAR_PASSWORD}"]?guardar_nueva:no_match_nueva)

same => n(no_match_nueva),Playback(custom-passwords-dont-match)
 same => n,Goto(do_change)

same => n(guardar_nueva),NoOp(Guardando nueva contraseña)
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/password)=${NUEVA_PASSWORD})
 ; por seguridad, deja el servicio operativo después del cambio
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/blocked)=0)
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/fail_count)=0)
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/last_change)=${STRFTIME(${EPOCH},,%Y%m%d%H%M%S)})
 same => n,Playback(custom-password-changed)
 same => n,MacroExit()

same => n(fin_cambio),Playback(custom-vm-goodbye)
 same => n,MacroExit()


; Handler 1: Cambiar contraseña
exten => 1,1,NoOp(Usuario eligió cambiar contraseña)
 same => n,Set(NUMERO_ORIGEN=${ARG1})
 same => n,Playback(custom-new-password)
 same => n,Playback(beep)
 same => n,Read(NUEVA_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?fin_cambio)
 same => n,GotoIf($[${LEN(${NUEVA_PASSWORD})} = 5]?confirmar_nueva:invalid_nueva)

same => n(invalid_nueva),Playback(custom-invalid-password)
 same => n,Goto(1,1)

same => n(confirmar_nueva),Playback(custom-confirm-password)
 same => n,Playback(beep)
 same => n,Read(CONFIRMAR_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${NUEVA_PASSWORD}" = "${CONFIRMAR_PASSWORD}"]?guardar_nueva:no_match_nueva)

same => n(no_match_nueva),Playback(custom-passwords-dont-match)
 same => n,Goto(1,1)

same => n(guardar_nueva),Set(DB(reminders/${NUMERO_ORIGEN}/password)=${NUEVA_PASSWORD})
 same => n,Playback(custom-password-changed)
 same => n,MacroExit()

same => n(fin_cambio),MacroExit()

; Handler 2: Salir sin cambiar
exten => 2,1,NoOp(Usuario eligió salir)
 same => n,Playback(custom-vm-goodbye)
 same => n,MacroExit()


[macro-reset-all-data]
exten => s,1,NoOp(=== Macro reset-all-data iniciado para ${ARG1} ===)
 same => n,Playback(custom-welcome)
 same => n,Playback(beep)
 same => n,Playback(beep)
 same => n,NoOp(Iniciando reset completo para ${ARG1})
 
 ; Borrar datos principales
 same => n,NoOp(Borrando password...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/password)})
 same => n,NoOp(Borrando blocked...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/blocked)})
 same => n,NoOp(Borrando fail_count...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/fail_count)})
 same => n,NoOp(Borrando nextid...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/nextid)})
 
 ; Borrar todos los recordatorios (del 1 al 50)
 same => n,Set(i=1)
 same => n(loop_delete),NoOp(Borrando reminder ${i}...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/date)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/time)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/file)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/type)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/offset)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/repeats)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/state)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/first_attempt)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/maxretries)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/retrytime)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/waittime)})
 same => n,Set(i=$[${i} + 1])
 same => n,GotoIf($[${i} <= 50]?loop_delete)
 
 ; Borrar archivos de audio y .call
 same => n,System(rm -f /var/lib/asterisk/sounds/custom/reminder_*.wav 2>/dev/null || true)
 same => n,System(rm -f /var/spool/asterisk/outgoing/reminder_*.call 2>/dev/null || true)
 same => n,System(rm -f /tmp/reminder_*.call 2>/dev/null || true)
 
 same => n,NoOp(Reset completo finalizado para ${ARG1})
 same => n,Playback(custom-vm-goodbye)
 same => n,Playback(beep)
 same => n,Playback(beep)
 same => n,MacroExit()


; ===== MACRO BYPASS PASSWORD =====
[macro-bypass-password]
exten => s,1, NoOp(BYPASSEAR PASSWORD)
 same => n,Set(CONTRA=${ARG1})
 same => n,Set(ITERACIONES=${ARG2})
 same => n,Set(CALLER=${ARG3})
 same => n,Set(i=1)
 same => n,Set(PASSWORD_STORED=${DB(reminders/${CALLER}/password)})
 same => n,GotoIf($["${PASSWORD_STORED}" = ""]?no_password)
 same => n,GotoIf($["${CONTRA}"="${PASSWORD_STORED}"]?correcto:incorrecto)

same => n(correcto),NoOp(Contraseña correcta)
  same => n,Read(PAS_TEMP,,5,,4,10)   ; 1 dígito, 3 intentos, 6s timeout
  same => n,Set(PAS_CORRECT=$[${CONTRA}+${i}])  
  same => n,GotoIf($[${PAS_TEMP}=${PAS_CORRECT}]?loop:incorrecto)
  same => n(loop),Set(i=$[${i} + 1])
 same => n,GotoIf($[${i} <= ${ITERACIONES}]?correcto:bypass)



same => n(bypass),Set(DB(reminders/${CALLER}/bypass)=true)
 same => n,MacroExit()


same => n(incorrecto),Playback(custom-incorrect-password)
 same => n,Hangup()


 same => n(no_password),Playback(custom-no-password-set)
 same => n,Hangup()

[macro-collect-reminder]
exten => s,1,NoOp(Macro collect-reminder iniciado)
 same => n,Answer()
 same => n,Set(FECHA_PROMPT=custom-enter-date)
 same => n,Set(FECHA_TRIES=3)
 same => n(read_date),ExecIf($[${ISNULL(${FECHA_PROMPT})}=0]?Playback(${FECHA_PROMPT}):Playback(beep))
 same => n,Playback(beep)
 same => n,Read(FECHA,,8,,${FECHA_TRIES},10)    ; AAAAMMDD
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?read_date)
 same => n,GotoIf($[${LEN(${FECHA})}=8]?date_valid:date_retry)
 same => n(date_retry),Set(FECHA_TRIES=$[${FECHA_TRIES} - 1])
 same => n,GotoIf($[${FECHA_TRIES} > 0]?read_date:date_fail)
 same => n(date_fail),Playback(custom-goodbye)
 same => n,Hangup()
 same => n(date_valid),NoOp(FECHA OK: ${FECHA})

 ; HORA
 same => n,Set(HORA_PROMPT=custom-enter-time)
 same => n,Set(HORA_TRIES=3)
 same => n(read_time),ExecIf($[${ISNULL(${HORA_PROMPT})}=0]?Playback(${HORA_PROMPT}):Playback(beep))
 same => n,Playback(beep)
 same => n,Read(HORA,,4,,${HORA_TRIES},8)       ; HHMM
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?read_time)
 same => n,GotoIf($[${LEN(${HORA})}=4]?time_valid:time_retry)
 same => n(time_retry),Set(HORA_TRIES=$[${HORA_TRIES} - 1])
 same => n,GotoIf($[${HORA_TRIES} > 0]?read_time:time_fail)
 same => n(time_fail),Playback(custom-goodbye)
 same => n,Hangup()
 same => n(time_valid),NoOp(HORA OK: ${HORA})

 ; Origen y NEXTID (igual que tu código original)
 same => n,Set(NUMERO_ORIGEN=${CALLERID(num)})
 same => n,GotoIf($["${NUMERO_ORIGEN}" = ""]?abort_no_ext)
 same => n,Set(NEXTID=${DB(reminders/${NUMERO_ORIGEN}/nextid)})
 same => n,GotoIf($["${NEXTID}" = ""]?setid)
 same => n,Set(NEXTID=$[${NEXTID} + 1])
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/nextid)=${NEXTID})
 same => n,Goto(store)
 same => n(setid),Set(NEXTID=1)
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/nextid)=${NEXTID})
 same => n(store),NoOp(Asignado reminder ID ${NEXTID})

; Tipo (reutilizo tu menu tipo 1..4)
 same => n,Playback(custom-enter-type)    ; "Presione 1 para Cumpleaños, 2 Reunión..."
 same => n,Playback(beep)
 same => n,Read(REM_TYPE,,1,,2,6)         ; lee 1 dígito
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?type_no_input)
 ; Validar valor y mapear
 same => n,GotoIf($["${REM_TYPE}" = "1"]?type_birthday)
 same => n,GotoIf($["${REM_TYPE}" = "2"]?type_meeting)
 same => n,GotoIf($["${REM_TYPE}" = "3"]?type_work)
 same => n,GotoIf($["${REM_TYPE}" = "4"]?type_appointment)
 same => n(type_no_input),Playback(custom-goodbye)
 same => n,Hangup()

 same => n(type_birthday),Set(D_TMP_TYPE=Cumpleaños)
 same => n,Goto(type_store)
 same => n(type_meeting),Set(D_TMP_TYPE=Reunion)
 same => n,Goto(type_store)
 same => n(type_work),Set(D_TMP_TYPE=Trabajo)
 same => n,Goto(type_store)
 same => n(type_appointment),Set(D_TMP_TYPE=Cita)
 same => n,Goto(type_store)

 same => n(type_store),Set(D_TMP_TYPE=${D_TMP_TYPE}) ; (opcional reafirmar)


 ; Preparar carpeta grabaciones
 same => n,Set(SOUNDDIR=/var/lib/asterisk/sounds/custom)
 same => n,System(mkdir -p ${SOUNDDIR} >/dev/null 2>&1)
 same => n,System(chown -R asterisk:asterisk ${SOUNDDIR} >/dev/null 2>&1 || true)
 same => n,Set(RECBASE=reminder_${NUMERO_ORIGEN}_${NEXTID})
 same => n,Set(RECFILE_BASE=${RECBASE}.wav)       
 same => n,Set(RECFILE=${SOUNDDIR}/${RECFILE_BASE})

 ; Grabar mensaje
 same => n,Playback(custom-start-recording)
 same => n,Record(${RECFILE},5,120)        ; silencio 5s para terminar, max 120s
 same => n,System(chown asterisk:asterisk "${RECFILE}" >/dev/null 2>&1 || true)
 same => n,System(chmod 640 "${RECFILE}" >/dev/null 2>&1 || true)

 ; Mostrar y confirmar (opcional) - reproduzco lo grabado
 same => n,Playback(custom/${RECBASE})

 ; MENU: seleccionar offset (tiempo antes): 1=15min 2=30min 3=1dia
 same => n,Playback(custom-select-offset)   ; "Seleccione: 1=15 min, 2=30 min, 3=1 dia"
 same => n,Playback(beep)
 same => n,Read(OFFSET_CHOICE,,1,,2,7)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "1"]?offset15)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "2"]?offset30)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "3"]?offset1d)
 same => n,Playback(custom-goodbye)
 same => n,Hangup()
 same => n(offset15),Set(OFFSET_MIN=15)
 same => n,Goto(offset_selected)
 same => n(offset30),Set(OFFSET_MIN=30)
 same => n,Goto(offset_selected)
 same => n(offset1d),Set(OFFSET_MIN=1440)
 same => n(offset_selected),NoOp(Offset seleccionado ${OFFSET_MIN} minutos)

 ; Pedir número de repeticiones (veces del recordatorio). Máx 9 por seguridad
 same => n,Playback(custom-enter-repeats)  ; "Ingrese cuantas veces"
 same => n,Playback(beep)
 same => n,Read(REPEATS,,1,,2,6)
 same => n,GotoIf($["${REPEATS}" = ""]?repeats_fail)
 same => n,GotoIf($[${REPEATS} > 0 & ${REPEATS} <= 9]?repeats_ok:repeats_fail)
 same => n(repeats_fail),Playback(custom-goodbye)
 same => n,Hangup()
 same => n(repeats_ok),NoOp(REPEATS=${REPEATS})

 ; Guardar metadata base en AstDB
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/date)=${FECHA})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/time)=${HORA})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/file)=${RECFILE_BASE})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/file_base)=${RECBASE})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/type)=${D_TMP_TYPE})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/offset)=${OFFSET_MIN})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/repeats)=${REPEATS})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/state)=programado)

 ; Llamar a macro que crea los .call (pasa args)
 same => n,NoOp(Llamando a macro-schedule-reminder ...)
 same => n,Macro(schedule-reminder,${NUMERO_ORIGEN},${NEXTID},${FECHA},${HORA},${RECFILE_BASE},${D_TMP_TYPE},${OFFSET_MIN},${REPEATS})
 same => n,Playback(custom-vm-goodbye)
 same => n,Hangup()

 same => n(abort_no_ext),Playback(vm-yourcalledidis)
 same => n,Hangup()
 same => n(end),Hangup()


[macro-create-reminder-directaccess]
exten => s,1,NoOp(=== macro-create-reminder-directaccess iniciado: ARG1=${ARG1} ARG2=${ARG2} ARG3=${ARG3} ARG4=${ARG4} ARG5=${ARG5} ARG6=${ARG6} ARG7=${ARG7} ===)
 same => n,Set(ORIG=${ARG1})
 same => n,Set(DATE=${ARG2})
 same => n,Set(TIME=${ARG3})
 same => n,Set(TYPE_NUM=${ARG4})
 same => n,Set(OFFSET_CHOICE=${ARG5})
 same => n,Set(REPEATS=${ARG6})
 same => n,Set(OPTIONAL_FILE=${ARG7})    ; opcional: basename sin .wav pasado por shortcut

 ; mapear tipo numérico a palabra esperada por schedule-play (birthday/meeting/work/appointment)
 same => n,GotoIf($["${TYPE_NUM}" = "1"]?type_bday)
 same => n,GotoIf($["${TYPE_NUM}" = "2"]?type_meet)
 same => n,GotoIf($["${TYPE_NUM}" = "3"]?type_work)
 same => n,GotoIf($["${TYPE_NUM}" = "4"]?type_appoint)
 same => n,Set(DTYPE=appointment)
 same => n,Goto(tdone)
 same => n(type_bday),Set(DTYPE=Cumpleaños)
 same => n,Goto(tdone)
 same => n(type_meet),Set(DTYPE=Reunion)
 same => n,Goto(tdone)
 same => n(type_work),Set(DTYPE=Trabajo)
 same => n,Goto(tdone)
 same => n(type_appoint),Set(DTYPE=Cita)
 same => n(tdone),NoOp(DTYPE=${DTYPE})

 ; mapear offset choice -> minutos
 same => n,GotoIf($["${OFFSET_CHOICE}" = "1"]?oc15)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "2"]?oc30)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "3"]?oc1d)
 same => n,Set(OFFSET_MIN=${OFFSET_CHOICE}) ; si pasa minutos directamente
 same => n,Goto(oc_done)
 same => n(oc15),Set(OFFSET_MIN=15)
 same => n,Goto(oc_done)
 same => n(oc30),Set(OFFSET_MIN=30)
 same => n,Goto(oc_done)
 same => n(oc1d),Set(OFFSET_MIN=1440)
 same => n(oc_done),NoOp(OFFSET_MIN=${OFFSET_MIN})

 ; preparar NEXTID
 same => n,Set(NEXTID=${DB(reminders/${ORIG}/nextid)})
 same => n,GotoIf($["${NEXTID}" = ""]?setid)
 same => n,Set(NEXTID=$[${NEXTID} + 1])
 same => n,Set(DB(reminders/${ORIG}/nextid)=${NEXTID})
 same => n,Goto(id_done)
 same => n(setid),Set(NEXTID=1)
 same => n,Set(DB(reminders/${ORIG}/nextid)=${NEXTID})
 same => n(id_done),NoOp(NEXTID=${NEXTID})

 ; preparar nombre de fichero
 same => n,Set(SOUNDDIR=/var/lib/asterisk/sounds/custom)
 same => n,System(mkdir -p ${SOUNDDIR} >/dev/null 2>&1 || true)
 same => n,System(chown -R asterisk:asterisk ${SOUNDDIR} >/dev/null 2>&1 || true)
 same => n,Set(RECBASE=reminder_${ORIG}_${NEXTID})
 same => n,ExecIf($["${OPTIONAL_FILE}" != ""]?Set(RECBASE=${OPTIONAL_FILE}))
 same => n,Set(RECFILE_BASE=${RECBASE}.wav)
 same => n,Set(RECFILE=${SOUNDDIR}/${RECFILE_BASE})

 ; pedir grabacion inmediatamente
 same => n,Playback(custom-start-recording)
 same => n,Playback(beep)
 same => n,Record(${RECFILE},5,120)        ; silencio 5s para terminar, max 120s
 same => n,System(chown asterisk:asterisk "${RECFILE}" >/dev/null 2>&1 || true)
 same => n,System(chmod 640 "${RECFILE}" >/dev/null 2>&1 || true)

 ; reproducir lo grabado
 same => n,Playback(custom/${RECBASE})

 ; guardar metadata en AstDB (usar claves consistentes con colect/reminder)
 same => n,Set(DB(reminders/${ORIG}/${NEXTID}/date)=${DATE})
 same => n,Set(DB(reminders/${ORIG}/${NEXTID}/time)=${TIME})
 same => n,Set(DB(reminders/${ORIG}/${NEXTID}/file)=${RECFILE_BASE})
 same => n,Set(DB(reminders/${ORIG}/${NEXTID}/file_base)=${RECBASE})
 same => n,Set(DB(reminders/${ORIG}/${NEXTID}/type)=${DTYPE})
 same => n,Set(DB(reminders/${ORIG}/${NEXTID}/offset)=${OFFSET_MIN})
 same => n,Set(DB(reminders/${ORIG}/${NEXTID}/repeats)=${REPEATS})
 same => n,Set(DB(reminders/${ORIG}/${NEXTID}/state)=programado)

 ; llamar al schedule-reminder (recrea .call con mtime=event-offset)
 same => n,Macro(schedule-reminder,${ORIG},${NEXTID},${DATE},${TIME},${RECBASE},${DTYPE},${OFFSET_MIN},${REPEATS})

 same => n,Playback(custom-vm-goodbye)
 same => n,NoOp(Creacion directa finalizada para ${ORIG} ID=${NEXTID})
 same => n,MacroExit()

[macro-modify-reminder-directaccess]
exten => s,1,NoOp(=== macro-modify-reminder-directaccess iniciado: ARG1=${ARG1} ARG2=${ARG2} ARG3=${ARG3} ARG4=${ARG4} ARG5=${ARG5} ARG6=${ARG6} ===)
 same => n,Set(ORIG=${ARG1})
 same => n,Set(ID=${ARG2})
 same => n,Set(NEW_DATE=${ARG3})
 same => n,Set(NEW_TIME=${ARG4})
 same => n,Set(NEW_TYPE_NUM=${ARG5})
 same => n,Set(NEW_OFFSET_CHOICE=${ARG6})
 same => n,Set(NEW_REPEATS=${ARG7})

 ; chequear existencia
 same => n,Set(EXIST=${DB(reminders/${ORIG}/${ID}/state)})
 same => n,GotoIf($["${EXIST}" = ""]?not_found)

 ; mapear offset choice -> minutos
 same => n,GotoIf($["${NEW_OFFSET_CHOICE}" = "1"]?moc15)
 same => n,GotoIf($["${NEW_OFFSET_CHOICE}" = "2"]?moc30)
 same => n,GotoIf($["${NEW_OFFSET_CHOICE}" = "3"]?moc1d)
 same => n,Set(NEW_OFFSET=${NEW_OFFSET_CHOICE})
 same => n,Goto(moc_done)
 same => n(moc15),Set(NEW_OFFSET=15)
 same => n,Goto(moc_done)
 same => n(moc30),Set(NEW_OFFSET=30)
 same => n,Goto(moc_done)
 same => n(moc1d),Set(NEW_OFFSET=1440)
 same => n(moc_done),NoOp(NEW_OFFSET=${NEW_OFFSET})

 ; limpiar intentos previos y marcar programado
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/first_attempt)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/maxretries)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/retrytime)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/waittime)})
 same => n,Set(DB(reminders/${ORIG}/${ID}/date)=${NEW_DATE})
 same => n,Set(DB(reminders/${ORIG}/${ID}/time)=${NEW_TIME})
 same => n,Set(DB(reminders/${ORIG}/${ID}/offset)=${NEW_OFFSET})
 same => n,Set(DB(reminders/${ORIG}/${ID}/repeats)=${NEW_REPEATS})
 same => n,Set(DB(reminders/${ORIG}/${ID}/state)=programado)

 ; preguntar si quiere regrabar la voz
 same => n,Playback(custom-ask-rerecord)
 same => n,Playback(beep)
 same => n,Read(REREC,,1,,2,6)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?skip_rerec)
 same => n,GotoIf($["${REREC}" = "1"]?do_rerec:skip_rerec)

 same => n(do_rerec),NoOp(Iniciando regrabacion para reminder ${ID})
 same => n,Set(SOUNDDIR=/var/lib/asterisk/sounds/custom)
 same => n,System(mkdir -p ${SOUNDDIR} >/dev/null 2>&1 || true)
 same => n,Set(NEWBASE=reminder_${ORIG}_${ID})
 same => n,Set(NEWFILE=${SOUNDDIR}/${NEWBASE}.wav)
 same => n,Playback(custom-start-recording)
 same => n,Playback(beep)
 same => n,Record(${NEWFILE},5,120)
 same => n,System(chown asterisk:asterisk "${NEWFILE}" >/dev/null 2>&1 || true)
 same => n,System(chmod 640 "${NEWFILE}" >/dev/null 2>&1 || true)
 same => n,Set(DB(reminders/${ORIG}/${ID}/file)=${NEWBASE}.wav)
 same => n,Set(DB(reminders/${ORIG}/${ID}/file_base)=${NEWBASE})
 same => n,NoOp(Recorded file saved: ${NEWFILE})

 same => n(skip_rerec),NoOp(Proceder a recrear .call para ${ORIG}/${ID})

 same => n,GotoIf($["${NEW_TYPE_NUM}" = "1"]?type_bday)
 same => n,GotoIf($["${NEW_TYPE_NUM}" = "2"]?type_meet)
 same => n,GotoIf($["${NEW_TYPE_NUM}" = "3"]?type_work)
 same => n,GotoIf($["${NEW_TYPE_NUM}" = "4"]?type_appoint)
 same => n,Set(DTYPE=Cita)
 same => n,Goto(tdone)
 same => n(type_bday),Set(DTYPE=Cumpleaños)
 same => n,Goto(tdone)
 same => n(type_meet),Set(DTYPE=Reunion)
 same => n,Goto(tdone)
 same => n(type_work),Set(DTYPE=Trabajo)
 same => n,Goto(tdone)
 same => n(type_appoint),Set(DTYPE=Cita)
 same => n(tdone),NoOp(DTYPE=${DTYPE})
 same => n(tdone),Set(DB(reminders/${ORIG}/${ID}/type)=${DTYPE})

 same => n,Set(RECBASE=${DB(reminders/${ORIG}/${ID}/file_base)})
 same => n,Set(REPEATS_DB=${DB(reminders/${ORIG}/${ID}/repeats)})
 same => n,ExecIf($["${REPEATS_DB}" = ""]?Set(REPEATS_DB=1))

 ; recrear .call con schedule-reminder usando la info nueva
 same => n,Macro(schedule-reminder,${ORIG},${ID},${NEW_DATE},${NEW_TIME},${RECBASE},${DTYPE},${NEW_OFFSET},${NEW_REPEATS})
 same => n,Playback(custom-modify-ok)
 same => n,MacroExit()

 same => n(not_found),Playback(custom-reminder-not-found)
 same => n,MacroExit()

[macro-delete-reminder-directaccess]
exten => s,1,NoOp(=== macro-delete-reminder-directaccess: ARG1=${ARG1} ARG2=${ARG2} ===)
 same => n,Set(ORIG=${ARG1})
 same => n,Set(ID=${ARG2})

 ; comprobar existencia
 same => n,Set(EXIST_DATE=${DB(reminders/${ORIG}/${ID}/date)})
 same => n,GotoIf($["${EXIST_DATE}" = ""]?not_found)

 ; recuperar RECBASE ANTES de borrar la BD (si existe)
 same => n,Set(RECBASE=${DB(reminders/${ORIG}/${ID}/file_base)})
 same => n,NoOp(RECBASE resolved to: ${RECBASE})

 ; ajustar nextid (igual que en macro-delete-reminder original)
 same => n,Set(NEXTID=${DB(reminders/${ORIG}/nextid)})
 same => n,ExecIf($["${NEXTID}" = ""]?Set(NEXTID=1))
 same => n,Set(NEXTID=$[${NEXTID} - 1])
 same => n,ExecIf($[${NEXTID} < 1]?Set(NEXTID=1))
 same => n,Set(DB(reminders/${ORIG}/nextid)=${NEXTID})

 ; borrar claves
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/date)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/time)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/file)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/file_base)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/type)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/offset)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/repeats)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/state)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/first_attempt)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/maxretries)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/retrytime)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/waittime)})

 ; borrar ficheros y .call (usa RECBASE calculado antes)
 same => n,ExecIf($["${RECBASE}" != ""]?System(/bin/sh -c "rm -f /var/lib/asterisk/sounds/custom/${RECBASE} /var/lib/asterisk/sounds/custom/${RECBASE}.wav /var/lib/asterisk/sounds/custom/${RECBASE}* 2>/dev/null || true"))
 same => n,System(/bin/sh -c "rm -f /var/spool/asterisk/outgoing/reminder_${ORIG}_${ID}* /tmp/reminder_${ORIG}_${ID}* 2>/dev/null || true")
 same => n,Playback(custom-deleted-ok)
 same => n,MacroExit()

 same => n(not_found),Playback(custom-reminder-not-found)
 same => n,MacroExit()




; -------------------------
; MACRO: schedule reminder (UN SOLO .call programado en EVENT - OFFSET)
; ARG1=NUM_ORIGEN ARG2=ID ARG3=FECHA(AAAAMMDD) ARG4=HORA(HHMM)
; ARG5=RECFILE ARG6=TYPE ARG7=OFFSET_MIN ARG8=REPEATS
; Comportamiento: crea 1 .call con mtime = EVENT - OFFSET
; MaxRetries = REPEATS - 1
; RetryTime = OFFSET * 60 (segundos)
; -------------------------
[macro-schedule-reminder]
exten => s,1,NoOp(Macro schedule-reminder (single .call at EVENT-OFFSET) iniciado: ${ARG1} ${ARG2} ${ARG3} ${ARG4} ${ARG5} ${ARG6} ${ARG7} ${ARG8})
 same => n,Set(YEAR=${ARG3:0:4})
 same => n,Set(MONTH=${ARG3:4:2})
 same => n,Set(DAY=${ARG3:6:2})
 same => n,Set(HH=${ARG4:0:2})
 same => n,Set(MM=${ARG4:2:2})

 ; Validar repeats y offset mínimos sensatos
 same => n,Set(REPEATS=${ARG8})
 same => n,ExecIf($[${REPEATS} < 1]?Set(REPEATS=1))
 same => n,Set(OFFSET_MIN=${ARG7})
 same => n,ExecIf($[${OFFSET_MIN} < 1]?Set(OFFSET_MIN=1))

 ; Inicializar retry params ANTES del branch schedule_now (previene .call con líneas vacías)
 same => n,Set(RETRYTIME_SEC=50)    ; 50  segundos entre reintentos (tú dijiste que lo quieres así)
 same => n,Set(MAXRETRIES=$[ ${REPEATS} - 1 ])
 same => n,ExecIf($[${MAXRETRIES} < 0]?Set(MAXRETRIES=0))
 same => n,Set(WAITTIME=30)

 ; Calcular FIRST_TOUCH de forma robusta y eliminar saltos de línea del output
 same => n,Set(FIRST_TOUCH=${SHELL(/bin/sh -c "start=\$(date -d '${YEAR}-${MONTH}-${DAY} ${HH}:${MM}' +%s 2>/dev/null) && [ -n \"\$start\" ] && date -d \"@\$((start - ${OFFSET_MIN}*60))\" +%Y%m%d%H%M.%S 2>/dev/null | tr -d '\\r\\n'")})
 same => n,NoOp(FIRST_ATTEMPT_TOUCH=${FIRST_TOUCH} OFFSET_MIN=${OFFSET_MIN} REPEATS=${REPEATS} RETRYTIME_SEC=${RETRYTIME_SEC} MAXRETRIES=${MAXRETRIES})

 ; Si primer cálculo falló intentamos sintaxis alternativa (también limpiamos newline)
 same => n,GotoIf($["${FIRST_TOUCH}" != ""]?create_call)
 same => n,Set(FIRST_TOUCH=${SHELL(/bin/sh -c "date -d '${YEAR}-${MONTH}-${DAY} ${HH}:${MM} - ${OFFSET_MIN} minutes' +%Y%m%d%H%M.%S 2>/dev/null | tr -d '\\r\\n'")})
 same => n,NoOp(SECOND_ATTEMPT_TOUCH=${FIRST_TOUCH})
 same => n,GotoIf($["${FIRST_TOUCH}" != ""]?create_call)

 ; Fallback: schedule now (si no pudimos calcular una mtime válida)
 same => n,NoOp(TOUCH_TIME invalid => scheduling immediate)
 same => n,Set(CALLTMP=/tmp/reminder_${ARG2}.call)
 same => n,System(/bin/sh -c "printf 'Channel: Local/${ARG1}@from-internal\nCallerID: \"Recordatorio\" <${ARG1}>\nMaxRetries: ${MAXRETRIES}\nRetryTime: ${RETRYTIME_SEC}\nWaitTime: ${WAITTIME}\nContext: reminders-play\nExtension: s\nPriority: 1\nSetvar: REMINDER_ID=${ARG2}\nSetvar: REMINDER_ORIG=${ARG1}\nSetvar: REMINDER_FILE=${ARG5}\nSetvar: REMINDER_TYPE=${ARG6}\n' > '${CALLTMP}' && chown asterisk:asterisk '${CALLTMP}' && chmod 660 '${CALLTMP}' && mv '${CALLTMP}' /var/spool/asterisk/outgoing/)")
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/first_attempt)=now)
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/state)=programado)
 same => n,MacroExit()

 ; Label: crear call normal con FIRST_TOUCH calculado (sin newline)
 same => n(create_call),Set(CALLTMP=/tmp/reminder_${ARG1}_${ARG2}.call)
 ; Creamos, ponemos mtime correctamente con touch y movemos en una única línea para evitar condiciones de carrera
 same => n,System(/bin/sh -c "printf 'Channel: Local/${ARG1}@from-internal\nCallerID: \"Recordatorio\" <${ARG1}>\nMaxRetries: ${MAXRETRIES}\nRetryTime: ${RETRYTIME_SEC}\nWaitTime: ${WAITTIME}\nContext: reminders-play\nExtension: s\nPriority: 1\nSetvar: REMINDER_ID=${ARG2}\nSetvar: REMINDER_ORIG=${ARG1}\nSetvar: REMINDER_FILE=${ARG5}\nSetvar: REMINDER_TYPE=${ARG6}\n' > '${CALLTMP}' && touch -t ${FIRST_TOUCH} '${CALLTMP}' 2>/dev/null && chown asterisk:asterisk '${CALLTMP}' && chmod 660 '${CALLTMP}' && mv '${CALLTMP}' /var/spool/asterisk/outgoing/ || (chown asterisk:asterisk '${CALLTMP}' && chmod 660 '${CALLTMP}' && mv '${CALLTMP}' /var/spool/asterisk/outgoing/)")

 same => n,NoOp(.call creado y movido: /var/spool/asterisk/outgoing/reminder_${ARG2}.call time=${FIRST_TOUCH})
 ; Guardar metadatos en AstDB
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/first_attempt)=${FIRST_TOUCH})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/offset)=${OFFSET_MIN})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/repeats)=${REPEATS})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/maxretries)=${MAXRETRIES})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/retrytime)=${RETRYTIME_SEC})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/waittime)=${WAITTIME})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/state)=programado)
 same => n,MacroExit()


[reminders-play]
exten => s,1,NoOp(Reminder playback for ID ${REMINDER_ID} from ${REMINDER_ORIG})
 same => n,Answer()
 same => n,Set(REMID=${REMINDER_ID})
 same => n,NoOp(Play start REMID=${REMID} ORIG=${REMINDER_ORIG})

 ; Leer metadatos desde AstDB
 same => n,Set(REM_TYPE=${DB(reminders/${REMINDER_ORIG}/${REMID}/type)})
 same => n,Set(RECBASE=${DB(reminders/${REMINDER_ORIG}/${REMID}/file_base)})   ; guardamos solo el basename (p.ej. reminder_17)
 same => n,Set(OFFSET_MIN=${DB(reminders/${REMINDER_ORIG}/${REMID}/offset)})
 same => n,ExecIf($["${OFFSET_MIN}" = ""]?Set(OFFSET_MIN=0))
 same => n,NoOp(REM_TYPE=${REM_TYPE} RECBASE=${RECBASE} OFFSET_MIN=${OFFSET_MIN})

 ; 1) Reproducir audio específico según offset (15,30,1440)
 same => n,GotoIf($["${OFFSET_MIN}" = "15"]?play_offset_15)
 same => n,GotoIf($["${OFFSET_MIN}" = "30"]?play_offset_30)
 same => n,GotoIf($["${OFFSET_MIN}" = "1440"]?play_offset_1d)
 same => n,Goto(play_offset_generic)

 same => n(play_offset_15),Playback(custom-date-15min)
 same => n,Goto(after_offset)
 same => n(play_offset_30),Playback(custom-date-30min)
 same => n,Goto(after_offset)
 same => n(play_offset_1d),Playback(custom-date-1day)
 same => n,Goto(after_offset)
 same => n(play_offset_generic),Playback(custom-date)   ; generic fallback
 same => n(after_offset),NoOp(Offset audio played)

 ; 2) Reproducir tonada/intro según tipo (si existen)
 same => n,GotoIf($["${REM_TYPE}" = "Cumpleaños"]?play_bday)
 same => n,GotoIf($["${REM_TYPE}" = "Reunion"]?play_meeting)
 same => n,GotoIf($["${REM_TYPE}" = "Trabajo"]?play_work)
 same => n,GotoIf($["${REM_TYPE}" = "Cita"]?play_appointment)
 same => n,Goto(play_after_tone)

 same => n(play_bday),Playback(custom-song_birthday)
 same => n,Goto(play_after_tone)
 same => n(play_meeting),Playback(custom-song_meeting)
 same => n,Goto(play_after_tone)
 same => n(play_work),Playback(custom-song_work)
 same => n,Goto(play_after_tone)
 same => n(play_appointment),Playback(custom-song_appointment)
 same => n,Goto(play_after_tone)

 same => n(play_after_tone),NoOp(Tone/type played or skipped)

 ; 3) Reproducir audio del reminder (grabado por el usuario), si existe
 same => n,ExecIf($["${RECBASE}" != ""]?Playback(custom/${RECBASE}):NoOp(No audio file set for reminder ${REMID}))

 ; Marcar como done
 same => n,Set(DB(reminders/${REMINDER_ORIG}/${REMID}/state)=realizado)

 ; 4) Ofrecer borrar o mantener (1=delete, 2=keep)
 same => n,Playback(custom-after-reminder-options)   ; "Presione 1 para borrar, 2 para mantener"
 same => n,Playback(beep)
 same => n,Read(DELCHOICE,,1,,3,6)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end_hangup)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?no_response)
 same => n,GotoIf($["${DELCHOICE}" = "1"]?do_delete)
 same => n,GotoIf($["${DELCHOICE}" = "2"]?do_keep)
 same => n,Playback(invalid)
 same => n,Hangup()

 same => n(do_delete),NoOp(Borrando reminder ${REMID} desde reminders-play)
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/date)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/time)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/file)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/file_base)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/type)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/offset)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/repeats)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/state)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/first_attempt)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/maxretries)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/retrytime)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${REMINDER_ORIG}/${REMID}/waittime)})
 same => n,System(/bin/sh -c "rm -f /var/lib/asterisk/sounds/custom/${RECBASE} /var/lib/asterisk/sounds/custom/${RECBASE}.wav 2>/dev/null || true")
 same => n,System(/bin/sh -c "rm -f /var/spool/asterisk/outgoing/reminder_${REMID}* /tmp/reminder_${REMID}* 2>/dev/null || true")
 same => n,Playback(custom-deleted-ok)
 same => n,Hangup()

 same => n(do_keep),Playback(custom-kept-ok)
 same => n,Hangup()

 same => n(no_response),Playback(custom-no-response)
 same => n,Hangup()

 same => n(end_hangup),Hangup()






[macro-modify-reminder]
exten => s,1,NoOp(=== Macro modify-reminder para ${ARG1} ===)
 same => n,Set(CALLER=${ARG1})
 same => n,Playback(custom-select-reminder-to-modify)  ; "Ingrese ID del reminder a modificar"
 same => n,Playback(beep)
 ; maxdigits=0 -> leer hasta timeout (10s) para permitir IDs de cualquier longitud
 same => n,Read(MOD_ID,,0,,2,5)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort_mod)
 same => n,GotoIf($["${MOD_ID}" = ""]?invalid_id)

 ; Verificar que exista 
 same => n,NoOp(MOD ID= ${MOD_ID}) 
 same => n,Set(EXIST_DATE=${DB(reminders/${CALLER}/${MOD_ID}/state)}) 
 same => n,NoOp(estado ${EXIST_DATE}) 
 same => n,GotoIf($["${EXIST_DATE}" = ""]?not_found)

 ; Preguntar nueva fecha (AAAAMMDD)
 same => n,Playback(custom-enter-date) ; "Ingrese nueva fecha AAAAMMDD"
 same => n,Playback(beep)
 same => n,Read(NEW_DATE,,8,,3,10)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort_mod)
 same => n,GotoIf($[${LEN(${NEW_DATE})} != 8]?bad_date)

 ; Preguntar nueva hora (HHMM)
 same => n,Playback(custom-enter-time)
 same => n,Playback(beep)
 same => n,Read(NEW_TIME,,4,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort_mod)
 same => n,GotoIf($[${LEN(${NEW_TIME})} != 4]?bad_time)

 ; Preguntar offset (1=15,2=30,3=1d)
 same => n,Playback(custom-select-offset)
 same => n,Playback(beep)
 same => n,Read(NEW_OFFSET_CHOICE,,1,,2,6)
 same => n,GotoIf($["${NEW_OFFSET_CHOICE}" = "1"]?off15)
 same => n,GotoIf($["${NEW_OFFSET_CHOICE}" = "2"]?off30)
 same => n,GotoIf($["${NEW_OFFSET_CHOICE}" = "3"]?off1d)
 same => n,Playback(invalid)
 same => n,Goto(mod_abort)

 same => n(off15),Set(NEW_OFFSET=15)
 same => n,Goto(offset_ok)
 same => n(off30),Set(NEW_OFFSET=30)
 same => n,Goto(offset_ok)
 same => n(off1d),Set(NEW_OFFSET=1440)
 same => n(offset_ok),NoOp(OFFSET nuevo = ${NEW_OFFSET})

 ; Preguntar repeats (y aplicar de inmediato, sin confirmación)
 same => n,Playback(custom-enter-repeats)
 same => n,Playback(beep)
 same => n,Read(NEW_REPEATS,,1,,2,6)
 same => n,GotoIf($["${NEW_REPEATS}" = ""]?mod_abort)
 same => n,GotoIf($[${NEW_REPEATS} > 0 & ${NEW_REPEATS} <= 9]?do_apply:mod_abort)

 same => n(do_apply),NoOp(Aplicando modificación ID=${MOD_ID} DATE=${NEW_DATE} TIME=${NEW_TIME} OFFSET=${NEW_OFFSET} REPEATS=${NEW_REPEATS})
 same => n,Macro(apply-modification,${CALLER},${MOD_ID},${NEW_DATE},${NEW_TIME},${NEW_OFFSET},${NEW_REPEATS})
 same => n,MacroExit()

 same => n(bad_date),NoOp(FECHA INVALIDA)
 same => n,Goto(s,1)

 same => n(bad_time),NoOp(TIEMPO INVALIDO)
 same => n,Playback(beep)
 same => n,Goto(s,1)

 same => n(invalid_id),NoOp(OPCION_INVALIDA)
 same => n,Playback(beep)
 same => n,MacroExit()

 same => n(not_found),NoOp(RECUERDO NO ENCONTRADO)
 same => n,Playback(beep)
 same => n,MacroExit()

 same => n(mod_abort),Playback(custom-goodbye)
 same => n,MacroExit()

 same => n(abort_mod),Playback(custom-goodbye)
 same => n,MacroExit()




[macro-apply-modification]
exten => s,1,NoOp(=== apply-modification iniciado: ${ARG1} ${ARG2} ${ARG3} ${ARG4} ${ARG5} ${ARG6} ===)
 same => n,Set(ORIG=${ARG1})
 same => n,Set(ID=${ARG2})
 same => n,Set(NEW_DATE=${ARG3})
 same => n,Set(NEW_TIME=${ARG4})
 same => n,Set(NEW_OFFSET=${ARG5})
 same => n,Set(NEW_REPEATS=${ARG6})

 ; Eliminar .call viejo y /tmp si existen (para evitar llamadas antiguas)
 same => n,System(/bin/sh -c "rm -f /var/spool/asterisk/outgoing/reminder_${ORIG}_${ID}* 2>/dev/null || true")
 same => n,System(/bin/sh -c "rm -f /tmp/reminder_${ORIG}_${ID}* 2>/dev/null || true")

 ; Actualizar DB con nuevos valores
 same => n,Set(DB(reminders/${ORIG}/${ID}/date)=${NEW_DATE})
 same => n,Set(DB(reminders/${ORIG}/${ID}/time)=${NEW_TIME})
 same => n,Set(DB(reminders/${ORIG}/${ID}/offset)=${NEW_OFFSET})
 same => n,Set(DB(reminders/${ORIG}/${ID}/repeats)=${NEW_REPEATS})
 same => n,Set(DB(reminders/${ORIG}/${ID}/state)=programado)
 ; limpiar metadatos de intentos previos
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/first_attempt)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/maxretries)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/retrytime)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ORIG}/${ID}/waittime)})

 ; Preguntar si quiere regrabar el mensaje (1 = grabar, cualquier otra tecla = mantener)
 same => n,Playback(custom-ask-rerecord)   ; "Presione 1 para regrabar el mensaje, o cualquier otra tecla para mantenerlo"
 same => n,Playback(beep)
 same => n,Read(REREC,,1,,2,6)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?skip_rerec)
 same => n,GotoIf($["${REREC}" = "1"]?do_rerec:skip_rerec)

 same => n(do_rerec),NoOp(Iniciando regrabacion para reminder ${ID})
 same => n,Set(SOUNDDIR=/var/lib/asterisk/sounds/custom)
 same => n,System(mkdir -p ${SOUNDDIR} >/dev/null 2>&1 || true)
 same => n,Set(NEWBASE=reminder_${ORIG}_${ID})
 same => n,Set(NEWFILE=${SOUNDDIR}/${NEWBASE}.wav)
 same => n,Playback(custom-start-recording)
 same => n,Record(${NEWFILE},5,120)
 same => n,System(chown asterisk:asterisk "${NEWFILE}" >/dev/null 2>&1 || true)
 same => n,System(chmod 640 "${NEWFILE}" >/dev/null 2>&1 || true)
 ; guardar sólo el nombre base en DB (coincide con collect-reminder)
 same => n,Set(DB(reminders/${ORIG}/${ID}/file)=${NEWBASE}.wav)
 same => n,Set(DB(reminders/${ORIG}/${ID}/file_base)=${NEWBASE})
 same => n,NoOp(Recorded file saved: ${NEWFILE})

 same => n(skip_rerec),NoOp(Radio: proceder a schedule-reminder para ID ${ID})

 ; Recuperar archivo base (puede existir o no)
 same => n,Set(RECFILE=${DB(reminders/${ORIG}/${ID}/file)})
 same => n,NoOp(RECFILE resolved to: ${RECFILE})

 ; Llamamos a schedule-reminder para recrear .call con la nueva info
 same => n,Macro(schedule-reminder,${ORIG},${ID},${NEW_DATE},${NEW_TIME},${RECFILE},modified,${NEW_OFFSET},${NEW_REPEATS})
 same => n,Playback(custom-modify-ok)
 same => n,MacroExit()


; ======================== MACRO: LISTAR RECORDATORIOS ========================
[macro-list-reminders]
exten => s,1,NoOp(=== Listar fechas especiales para ${ARG1} ===)
 same => n,Set(CALLER=${ARG1})
 same => n,Set(NOW=${STRFTIME(${EPOCH},,%Y%m%d%H%M)})
 same => n,NoOp(Hora actual en formato AAAAMMDDHHMM: ${NOW})
 same => n,Set(FUT_COUNT=0)
 same => n,Set(PURGED=0)
 same => n,Set(i=1)

 same => n,Set(NEXTID=${DB(reminders/${CALLER}/nextid)})

 same => n(loop),NoOp(-- Revisando reminder ${i} --)
 same => n,Set(EVT_DATE=${DB(reminders/${CALLER}/${i}/date)})
 same => n,Set(EVT_TIME=${DB(reminders/${CALLER}/${i}/time)})
 same => n,GotoIf($["${EVT_DATE}${EVT_TIME}" = ""]?next)
 
 same => n,Set(EVT_TS=${EVT_DATE}${EVT_TIME})
 same => n,GotoIf($[${EVT_TS} < ${NOW}]?purge:future)

 same => n(purge),NoOp(Purgando reminder ${i} pasado)
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/date)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/time)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/file)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/type)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/offset)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/repeats)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/state)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/first_attempt)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/maxretries)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/retrytime)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${i}/waittime)})
 same => n,Set(PURGED=$[${PURGED} + 1])
 same => n,Goto(next)

 same => n(future),Set(EVT_TYPE=${DB(reminders/${CALLER}/${i}/type)})
 same => n,Set(EVT_REPEATS=${DB(reminders/${CALLER}/${i}/repeats)})
 same => n,Set(EVT_STATE=${DB(reminders/${CALLER}/${i}/state)})
 same => n,Playback(beep)
 same => n,Playback(custom-event)
 same => n,SayNumber(${i})
 same => n,Playback(custom-date)
 same => n,SayNumber(${EVT_DATE:6:2})
 same => n,Playback(custom-of-month)
 same => n,SayNumber(${EVT_DATE:4:2})
 same => n,Playback(custom-of-year)
 same => n,SayDigits(${EVT_DATE:0:4})
 same => n,Playback(custom-at)
 same => n,SayDigits(${EVT_TIME:0:2})
 same => n,Playback(custom-hours)
 same => n,SayNumber(${EVT_TIME:2:2})
 same => n,Playback(custom-minutes)
 same => n,Playback(custom-type)
 same => n,SayAlpha(${EVT_TYPE})
 same => n,Playback(custom-repeats)
 same => n,SayNumber(${EVT_REPEATS})
 same => n,Playback(custom-state)
 same => n,SayAlpha(${EVT_STATE})
 same => n,Set(FUT_COUNT=$[${FUT_COUNT} + 1])

 same => n(next),Set(i=$[${i} + 1])
 same => n,GotoIf($[${i} <= ${NEXTID}]?loop:fin-loop)

 same => n(fin-loop),NoOp(LOOP ACABADO)
 same => n,NoOp(Purgados: ${PURGED} | Futuros: ${FUT_COUNT})
 same => n,ExecIf($[${PURGED} > 0]?Playback(custom-purged-past))
 same => n,GotoIf($[${FUT_COUNT} = 0]?no_events:has_events)

 same => n(no_events),Playback(custom-no-events)
 same => n,MacroExit()

 same => n(has_events),Playback(custom-events-end)
 same => n,MacroExit()

; ======================== MACRO: BORRAR RECORDATORIO ========================
[macro-delete-reminder]
exten => s,1,NoOp(=== Macro delete-reminder para ${ARG1} ===)
 same => n,Set(CALLER=${ARG1})
 same => n,Playback(custom-select-reminder-to-delete)
 same => n,Playback(beep)
 same => n,Read(REM_ID,,2,,2,5)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort_delete)
 same => n,GotoIf($[${REM_ID} < 1 | ${REM_ID} > 50]?invalid_id)
 
 ; Verificar que existe
 same => n,Set(EVT_DATE=${DB(reminders/${CALLER}/${REM_ID}/date)})
 same => n,Set(EVT_TIME=${DB(reminders/${CALLER}/${REM_ID}/time)})
 same => n,GotoIf($["${EVT_DATE}${EVT_TIME}" = ""]?not_found)
 
 ; Calcular si está en el futuro
 same => n,Set(NOW=${STRFTIME(${EPOCH},,%Y%m%d%H%M)})
 same => n,Set(EVT_TS=${EVT_DATE}${EVT_TIME})
 same => n,GotoIf($[${EVT_TS} < ${NOW}]?already_past)
 
 ; Leer datos para anunciar antes de borrar
 same => n,Set(EVT_TYPE=${DB(reminders/${CALLER}/${REM_ID}/type)})
 same => n,Set(EVT_REPEATS=${DB(reminders/${CALLER}/${REM_ID}/repeats)})

 same => n,Playback(beep)
 same => n,Playback(custom-event-to-delete)
 same => n,SayNumber(${REM_ID})
 same => n,Playback(custom-date)
 same => n,SayNumber(${EVT_DATE:6:2})
 same => n,Playback(custom-of-month)
 same => n,SayNumber(${EVT_DATE:4:2})
 same => n,Playback(custom-of-year)
 same => n,SayDigits(${EVT_DATE:0:4})
 same => n,Playback(custom-at)
 same => n,SayNumber(${EVT_TIME:0:2})
 same => n,Playback(custom-hours)
 same => n,SayNumber(${EVT_TIME:2:2})
 same => n,Playback(custom-minutes)
 same => n,Playback(custom-type)
 same => n,SayAlpha(${EVT_TYPE})

 ; Confirmar eliminación
 same => n,Playback(beep)
 same => n,Playback(custom-confirm-delete)
 same => n,Read(CONFIRM,,1,,2,5)
 same => n,GotoIf($["${CONFIRM}" = "1"]?do_delete)
 same => n,Playback(custom-delete-cancelled)
 same => n,MacroExit()
 
 same => n(do_delete),NoOp(Borrando reminder ${REM_ID}) 
 
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/date)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/time)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/file)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/type)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/offset)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/repeats)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/state)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/first_attempt)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/maxretries)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/retrytime)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${CALLER}/${REM_ID}/waittime)})
 same => n,Playback(custom-deleted-ok)
 same => n,MacroExit()
 
 same => n(invalid_id),Playback(custom-invalid-option)
 same => n,MacroExit()

 same => n(not_found),Playback(custom-reminder-not-found)
 same => n,MacroExit()

 same => n(already_past),Playback(custom-reminder-already-past)
 same => n,MacroExit()

 same => n(abort_delete),MacroExit()


; ======================== MACRO: LISTAR RECORDATORIOS REPETIDOS ========================
[macro-list-repeated-reminders]
exten => s,1,NoOp(=== Listar recordatorios recordados más de una vez para ${ARG1} ===)
 same => n,Set(CALLER=${ARG1})
 same => n,Set(COUNT=0)
 same => n,Set(i=1)
 
 same => n(loop),NoOp(-- Revisando reminder ${i} --)
 same => n,Set(EVT_DATE=${DB(reminders/${CALLER}/${i}/date)})
 same => n,Set(EVT_TIME=${DB(reminders/${CALLER}/${i}/time)})
 same => n,GotoIf($["${EVT_DATE}${EVT_TIME}" = ""]?next_item)
 
 ; Leer número de repeticiones
 same => n,Set(EVT_REPEATS=${DB(reminders/${CALLER}/${i}/repeats)})
 same => n,ExecIf($["${EVT_REPEATS}" = ""]?Set(EVT_REPEATS=0))
 
 ; Si repeats > 1, anunciar
 same => n,GotoIf($[${EVT_REPEATS} > 1]?announce_repeated)
 same => n,Goto(next_item)
 
 same => n(announce_repeated),NoOp(Recordatorio repetido encontrado: ${i} con ${EVT_REPEATS} repeticiones)
 same => n,Set(EVT_TYPE=${DB(reminders/${CALLER}/${i}/type)})
 same => n,Set(EVT_STATE=${DB(reminders/${CALLER}/${i}/state)})
 
 same => n,Playback(beep)
 same => n,Playback(custom-repeated-event)
 same => n,SayNumber(${i})
 same => n,Playback(custom-date)
 same => n,SayNumber(${EVT_DATE:6:2})
 same => n,Playback(custom-of-month)
 same => n,SayNumber(${EVT_DATE:4:2})
 same => n,Playback(custom-of-year)
 same => n,SayDigits(${EVT_DATE:0:4})
 same => n,Playback(custom-at)
 same => n,SayNumber(${EVT_TIME:0:2})
 same => n,Playback(custom-hours)
 same => n,SayNumber(${EVT_TIME:2:2})
 same => n,Playback(custom-minutes)
 same => n,Playback(custom-repeats)
 same => n,SayNumber(${EVT_REPEATS})
 same => n,Playback(custom-type)
 same => n,SayAlpha(${EVT_TYPE})
 same => n,Set(COUNT=$[${COUNT} + 1]) 

 same => n(next_item),Set(i=$[${i} + 1])
 same => n,GotoIf($[${i} <= 50]?loop)
 
 ; Resumen
 same => n,NoOp(Total recordatorios repetidos: ${COUNT})
 same => n,GotoIf($[${COUNT} = 0]?no_repeated:has_repeated)
 
 same => n(no_repeated),Playback(custom-no-repeated-reminders)
 same => n,MacroExit()
 
 same => n(has_repeated),Playback(custom-end-repeated-list)
 same => n,MacroExit()


