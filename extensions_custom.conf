[from-internal-custom]
; ==================== SERVICIO PRINCIPAL *222# ====================
exten => _*222#,1,NoOp(=== Iniciando servicio *222# ===)
 same => n,Answer()
 same => n,Set(NUMERO_ORIGEN=${CALLERID(num)})
 same => n,GotoIf($["${NUMERO_ORIGEN}" = ""]?error_no_caller)
 
 ; Verificar si el servicio está bloqueado para este usuario
 same => n,Set(BLOQUEADO=${DB(reminders/${NUMERO_ORIGEN}/blocked)})
 same => n,GotoIf($["${BLOQUEADO}" = "1"]?servicio_bloqueado)
 
 ; Verificar si ya existe contraseña
 same => n,Set(PASSWORD_STORED=${DB(reminders/${NUMERO_ORIGEN}/password)})
 same => n,GotoIf($["${PASSWORD_STORED}" = ""]?primera_vez:validar_password)

same => n(primera_vez),Macro(create-password,${NUMERO_ORIGEN})
 same => n,Goto(menu_principal)

same => n(validar_password),Macro(validate-password,${NUMERO_ORIGEN})
 same => n,GotoIf($["${PASSWORD_VALID}" = "1"]?menu_principal:fin)

same => n(servicio_bloqueado),NoOp(Servicio bloqueado para ${NUMERO_ORIGEN})
 same => n,Playback(custom-service-blocked)
 same => n,Hangup()

same => n(menu_principal),NoOp(=== MENU PRINCIPAL ===)
 same => n,Background(custom-enter-menu)
 same => n,WaitExten(6)
 same => n,Playback(custom-vm-goodbye)
 same => n,Hangup()

same => n(error_no_caller),Playback(custom-system-error)
 same => n,Hangup()

same => n(fin),Hangup()

; --- HANDLERS DEL MENÚ ---
exten => 1,1,NoOp(Usuario pulsó 1)
 same => n,Playback(custom/option1-confirm)
 same => n,Hangup()

exten => 2,1,NoOp(Usuario pulsó 2 -> iniciar flow de recordatorio)
 same => n,Playback(custom/option2-confirm)
 same => n,Macro(collect-reminder)
 same => n,Hangup()


; ==================== SERVICIO DE DESBLOQUEO #222# ====================
exten => _#222#,1,NoOp(=== Servicio de desbloqueo #222# ===)
 same => n,Answer()
 same => n,Set(NUMERO_ORIGEN=${CALLERID(num)})
 same => n,GotoIf($["${NUMERO_ORIGEN}" = ""]?error_desbloqueo)
 same => n,Macro(unlock-and-change,${NUMERO_ORIGEN})
 same => n,Hangup()

same => n(error_desbloqueo),Playback(custom-system-error)
 same => n,Hangup()


; ==================== SERVICIO DE RESET *999# ====================
exten => _*999#,1,NoOp(=== Servicio de RESET COMPLETO *999# ===)
 same => n,Answer()
 same => n,Set(NUMERO_ORIGEN=${CALLERID(num)})
 same => n,GotoIf($["${NUMERO_ORIGEN}" = ""]?error_reset)
 same => n,Macro(reset-all-data,${NUMERO_ORIGEN})
 same => n,Hangup()

same => n(error_reset),Playback(custom-system-error)
 same => n,Hangup()


[macro-create-password]
exten => s,1,NoOp(=== Macro create-password iniciado para ${ARG1} ===)
 same => n,Playback(custom-welcome)
 same => n,Playback(custom-create-password)
 same => n,Playback(beep)
 same => n,Read(NUEVA_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?s,1)
 same => n,GotoIf($[${LEN(${NUEVA_PASSWORD})} = 5]?confirmar:invalid)

same => n(invalid),Playback(custom-invalid-password)
 same => n,Goto(s,1)

same => n(confirmar),NoOp(Confirmando contraseña: ${NUEVA_PASSWORD})
 same => n,Playback(custom-confirm-password)
 same => n,Playback(beep)
 same => n,Read(CONFIRMAR_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${NUEVA_PASSWORD}" = "${CONFIRMAR_PASSWORD}"]?guardar:no_match)

same => n(no_match),Playback(custom-passwords-dont-match)
 same => n,Goto(s,1)

same => n(guardar),NoOp(Guardando contraseña para ${ARG1})
 same => n,Set(DB(reminders/${ARG1}/password)=${NUEVA_PASSWORD})
 same => n,Set(DB(reminders/${ARG1}/blocked)=0)
 same => n,Set(DB(reminders/${ARG1}/fail_count)=0)
 same => n,Playback(custom-password-created)
 same => n,MacroExit()

same => n(abort),Hangup()


[macro-validate-password]
exten => s,1,NoOp(=== Macro validate-password iniciado para ${ARG1} ===)
 same => n,Set(PASSWORD_STORED=${DB(reminders/${ARG1}/password)})
 same => n,Set(FAIL_COUNT=${DB(reminders/${ARG1}/fail_count)})
 same => n,ExecIf($["${FAIL_COUNT}" = ""]?Set(FAIL_COUNT=0))
 same => n,Set(INTENTOS_RESTANTES=$[3 - ${FAIL_COUNT}])
 
 same => n(solicitar),Playback(custom-enter-password)
 same => n,Playback(beep)
 same => n,Read(PASSWORD_INPUT,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?solicitar)
 
 same => n,GotoIf($["${PASSWORD_INPUT}" = "${PASSWORD_STORED}"]?correcto:incorrecto)

same => n(correcto),NoOp(Contraseña correcta)
 same => n,Set(DB(reminders/${ARG1}/fail_count)=0)
 same => n,Playback(custom-access-granted)
 same => n,Set(PASSWORD_VALID=1)
 same => n,MacroExit()

same => n(incorrecto),NoOp(Contraseña incorrecta - Intento: ${FAIL_COUNT})
 same => n,Set(FAIL_COUNT=$[${FAIL_COUNT} + 1])
 same => n,Set(DB(reminders/${ARG1}/fail_count)=${FAIL_COUNT})
 same => n,Set(INTENTOS_RESTANTES=$[3 - ${FAIL_COUNT}])
 
 same => n,GotoIf($[${FAIL_COUNT} >= 3]?bloquear)
 
 same => n,Playback(custom-incorrect-password)
 same => n,SayNumber(${INTENTOS_RESTANTES})
 same => n,Playback(custom-attempts-remaining)
 same => n,Goto(solicitar)

same => n(bloquear),NoOp(Bloqueando servicio por intentos fallidos)
 same => n,Set(DB(reminders/${ARG1}/blocked)=1)
 same => n,Playback(custom-service-blocked)
 same => n,Set(PASSWORD_VALID=0)
 same => n,MacroExit()

same => n(abort),Set(PASSWORD_VALID=0)
 same => n,MacroExit()


[macro-unlock-and-change]
exten => s,1,NoOp(=== Macro unlock-and-change iniciado para ${ARG1} ===)
 same => n,Set(PASSWORD_STORED=${DB(reminders/${ARG1}/password)})
 same => n,GotoIf($["${PASSWORD_STORED}" = ""]?no_password)
 
 ; Solicitar contraseña actual
 same => n,Playback(custom-unlock-password)
 same => n,Playback(beep)
 same => n,Read(PASSWORD_INPUT,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${PASSWORD_INPUT}" = "${PASSWORD_STORED}"]?correcto:incorrecto)

same => n(correcto),NoOp(Contraseña correcta - Desbloqueando)
 same => n,Set(DB(reminders/${ARG1}/blocked)=0)
 same => n,Set(DB(reminders/${ARG1}/fail_count)=0)
 same => n,Playback(custom-service-unlocked)
 same => n,Goto(menu_cambio)

same => n(incorrecto),Playback(custom-incorrect-password)
 same => n,Playback(custom-unlock-failed)
 same => n,MacroExit()

same => n(no_password),Playback(custom-no-password-set)
 same => n,MacroExit()

; ===== Menú para cambiar contraseña (robusto sin WaitExten) =====
same => n(menu_cambio),Playback(custom-change-password-prompt)   ; "1 cambiar, 2 salir"
 same => n,Playback(beep)
 same => n,Read(MENUOPT,,1,,3,6)   ; 1 dígito, 3 intentos, 6s timeout
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?abort)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?menu_timeout)
 same => n,GotoIf($["${MENUOPT}" = "1"]?do_change)
 same => n,GotoIf($["${MENUOPT}" = "2"]?fin_cambio)
 same => n,Playback(invalid)
 same => n,Goto(menu_cambio)

same => n(menu_timeout),Playback(custom-vm-goodbye)
 same => n,MacroExit()

; ===== Flujo de cambio de contraseña =====
same => n(do_change),NoOp(Usuario eligió cambiar contraseña)
 same => n,Set(NUMERO_ORIGEN=${ARG1})
 same => n,Playback(custom-new-password)   ; "Ingrese nueva contraseña de 5 dígitos"
 same => n,Playback(beep)
 same => n,Read(NUEVA_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?fin_cambio)
 same => n,GotoIf($[${LEN(${NUEVA_PASSWORD})} = 5]?confirmar_nueva:invalid_nueva)

same => n(invalid_nueva),Playback(custom-invalid-password)
 same => n,Goto(do_change)

same => n(confirmar_nueva),Playback(custom-confirm-password)
 same => n,Playback(beep)
 same => n,Read(CONFIRMAR_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${NUEVA_PASSWORD}" = "${CONFIRMAR_PASSWORD}"]?guardar_nueva:no_match_nueva)

same => n(no_match_nueva),Playback(custom-passwords-dont-match)
 same => n,Goto(do_change)

same => n(guardar_nueva),NoOp(Guardando nueva contraseña)
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/password)=${NUEVA_PASSWORD})
 ; por seguridad, deja el servicio operativo después del cambio
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/blocked)=0)
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/fail_count)=0)
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/last_change)=${STRFTIME(${EPOCH},,%Y%m%d%H%M%S)})
 same => n,Playback(custom-password-changed)
 same => n,MacroExit()

same => n(fin_cambio),Playback(custom-vm-goodbye)
 same => n,MacroExit()


; Handler 1: Cambiar contraseña
exten => 1,1,NoOp(Usuario eligió cambiar contraseña)
 same => n,Set(NUMERO_ORIGEN=${ARG1})
 same => n,Playback(custom-new-password)
 same => n,Playback(beep)
 same => n,Read(NUEVA_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?fin_cambio)
 same => n,GotoIf($[${LEN(${NUEVA_PASSWORD})} = 5]?confirmar_nueva:invalid_nueva)

same => n(invalid_nueva),Playback(custom-invalid-password)
 same => n,Goto(1,1)

same => n(confirmar_nueva),Playback(custom-confirm-password)
 same => n,Playback(beep)
 same => n,Read(CONFIRMAR_PASSWORD,,5,,3,8)
 same => n,GotoIf($["${NUEVA_PASSWORD}" = "${CONFIRMAR_PASSWORD}"]?guardar_nueva:no_match_nueva)

same => n(no_match_nueva),Playback(custom-passwords-dont-match)
 same => n,Goto(1,1)

same => n(guardar_nueva),Set(DB(reminders/${NUMERO_ORIGEN}/password)=${NUEVA_PASSWORD})
 same => n,Playback(custom-password-changed)
 same => n,MacroExit()

same => n(fin_cambio),MacroExit()

; Handler 2: Salir sin cambiar
exten => 2,1,NoOp(Usuario eligió salir)
 same => n,Playback(custom-vm-goodbye)
 same => n,MacroExit()


[macro-reset-all-data]
exten => s,1,NoOp(=== Macro reset-all-data iniciado para ${ARG1} ===)
 same => n,Playback(custom-welcome)
 same => n,Playback(beep)
 same => n,Playback(beep)
 same => n,NoOp(Iniciando reset completo para ${ARG1})
 
 ; Borrar datos principales
 same => n,NoOp(Borrando password...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/password)})
 same => n,NoOp(Borrando blocked...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/blocked)})
 same => n,NoOp(Borrando fail_count...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/fail_count)})
 same => n,NoOp(Borrando nextid...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/nextid)})
 
 ; Borrar todos los recordatorios (del 1 al 50)
 same => n,Set(i=1)
 same => n(loop_delete),NoOp(Borrando reminder ${i}...)
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/date)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/time)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/file)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/type)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/offset)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/repeats)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/state)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/first_attempt)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/maxretries)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/retrytime)})
 same => n,Set(RESULT=${DB_DELETE(reminders/${ARG1}/${i}/waittime)})
 same => n,Set(i=$[${i} + 1])
 same => n,GotoIf($[${i} <= 50]?loop_delete)
 
 ; Borrar archivos de audio y .call
 same => n,System(rm -f /var/lib/asterisk/sounds/custom/reminder_*.wav 2>/dev/null || true)
 same => n,System(rm -f /var/spool/asterisk/outgoing/reminder_*.call 2>/dev/null || true)
 same => n,System(rm -f /tmp/reminder_*.call 2>/dev/null || true)
 
 same => n,NoOp(Reset completo finalizado para ${ARG1})
 same => n,Playback(custom-vm-goodbye)
 same => n,Playback(beep)
 same => n,Playback(beep)
 same => n,MacroExit()


[macro-collect-reminder]
exten => s,1,NoOp(Macro collect-reminder iniciado)
 same => n,Answer()
 same => n,Set(FECHA_PROMPT=custom-enter-date)
 same => n,Set(FECHA_TRIES=3)
 same => n(read_date),ExecIf($[${ISNULL(${FECHA_PROMPT})}=0]?Playback(${FECHA_PROMPT}):Playback(beep))
 same => n,Playback(beep)
 same => n,Read(FECHA,,8,,${FECHA_TRIES},10)    ; AAAAMMDD
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?read_date)
 same => n,GotoIf($[${LEN(${FECHA})}=8]?date_valid:date_retry)
 same => n(date_retry),Set(FECHA_TRIES=$[${FECHA_TRIES} - 1])
 same => n,GotoIf($[${FECHA_TRIES} > 0]?read_date:date_fail)
 same => n(date_fail),Playback(custom-goodbye)
 same => n,Hangup()
 same => n(date_valid),NoOp(FECHA OK: ${FECHA})

 ; HORA
 same => n,Set(HORA_PROMPT=custom-enter-time)
 same => n,Set(HORA_TRIES=3)
 same => n(read_time),ExecIf($[${ISNULL(${HORA_PROMPT})}=0]?Playback(${HORA_PROMPT}):Playback(beep))
 same => n,Playback(beep)
 same => n,Read(HORA,,4,,${HORA_TRIES},8)       ; HHMM
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?read_time)
 same => n,GotoIf($[${LEN(${HORA})}=4]?time_valid:time_retry)
 same => n(time_retry),Set(HORA_TRIES=$[${HORA_TRIES} - 1])
 same => n,GotoIf($[${HORA_TRIES} > 0]?read_time:time_fail)
 same => n(time_fail),Playback(custom-goodbye)
 same => n,Hangup()
 same => n(time_valid),NoOp(HORA OK: ${HORA})

 ; Origen y NEXTID (igual que tu código original)
 same => n,Set(NUMERO_ORIGEN=${CALLERID(num)})
 same => n,GotoIf($["${NUMERO_ORIGEN}" = ""]?abort_no_ext)
 same => n,Set(NEXTID=${DB(reminders/${NUMERO_ORIGEN}/nextid)})
 same => n,GotoIf($["${NEXTID}" = ""]?setid)
 same => n,Set(NEXTID=$[${NEXTID} + 1])
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/nextid)=${NEXTID})
 same => n,Goto(store)
 same => n(setid),Set(NEXTID=1)
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/nextid)=${NEXTID})
 same => n(store),NoOp(Asignado reminder ID ${NEXTID})

; Tipo (reutilizo tu menu tipo 1..4)
 same => n,Playback(custom-enter-type)    ; "Presione 1 para Cumpleaños, 2 Reunión..."
 same => n,Playback(beep)
 same => n,Read(REM_TYPE,,1,,2,6)         ; lee 1 dígito
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?type_no_input)
 ; Validar valor y mapear
 same => n,GotoIf($["${REM_TYPE}" = "1"]?type_birthday)
 same => n,GotoIf($["${REM_TYPE}" = "2"]?type_meeting)
 same => n,GotoIf($["${REM_TYPE}" = "3"]?type_work)
 same => n,GotoIf($["${REM_TYPE}" = "4"]?type_appointment)
 same => n(type_no_input),Playback(custom-goodbye)
 same => n,Hangup()

 same => n(type_birthday),Set(D_TMP_TYPE=birthday)
 same => n,Goto(type_store)
 same => n(type_meeting),Set(D_TMP_TYPE=meeting)
 same => n,Goto(type_store)
 same => n(type_work),Set(D_TMP_TYPE=work)
 same => n,Goto(type_store)
 same => n(type_appointment),Set(D_TMP_TYPE=appointment)
 same => n,Goto(type_store)

 same => n(type_store),Set(D_TMP_TYPE=${D_TMP_TYPE}) ; (opcional reafirmar)


 ; Preparar carpeta grabaciones
 same => n,Set(SOUNDDIR=/var/lib/asterisk/sounds/custom)
 same => n,System(mkdir -p ${SOUNDDIR} >/dev/null 2>&1)
 same => n,System(chown -R asterisk:asterisk ${SOUNDDIR} >/dev/null 2>&1 || true)
 same => n,Set(RECBASE=reminder_${NEXTID})
 same => n,Set(RECFILE_BASE=${RECBASE}.wav)       
 same => n,Set(RECFILE=${SOUNDDIR}/${RECFILE_BASE})

 ; Grabar mensaje
 same => n,Playback(custom-start-recording)
 same => n,Record(${RECFILE},5,120)        ; silencio 5s para terminar, max 120s
 same => n,System(chown asterisk:asterisk "${RECFILE}" >/dev/null 2>&1 || true)
 same => n,System(chmod 640 "${RECFILE}" >/dev/null 2>&1 || true)

 ; Mostrar y confirmar (opcional) - reproduzco lo grabado
 same => n,Playback(custom/${RECBASE})

 ; MENU: seleccionar offset (tiempo antes): 1=15min 2=30min 3=1dia
 same => n,Playback(custom-select-offset)   ; "Seleccione: 1=15 min, 2=30 min, 3=1 dia"
 same => n,Playback(beep)
 same => n,Read(OFFSET_CHOICE,,1,,2,7)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "1"]?offset15)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "2"]?offset30)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "3"]?offset1d)
 same => n,Playback(custom-goodbye)
 same => n,Hangup()
 same => n(offset15),Set(OFFSET_MIN=15)
 same => n,Goto(offset_selected)
 same => n(offset30),Set(OFFSET_MIN=30)
 same => n,Goto(offset_selected)
 same => n(offset1d),Set(OFFSET_MIN=1440)
 same => n(offset_selected),NoOp(Offset seleccionado ${OFFSET_MIN} minutos)

 ; Pedir número de repeticiones (veces del recordatorio). Máx 9 por seguridad
 same => n,Playback(custom-enter-repeats)  ; "Ingrese cuantas veces"
 same => n,Playback(beep)
 same => n,Read(REPEATS,,1,,2,6)
 same => n,GotoIf($["${REPEATS}" = ""]?repeats_fail)
 same => n,GotoIf($[${REPEATS} > 0 & ${REPEATS} <= 9]?repeats_ok:repeats_fail)
 same => n(repeats_fail),Playback(custom-goodbye)
 same => n,Hangup()
 same => n(repeats_ok),NoOp(REPEATS=${REPEATS})

 ; Guardar metadata base en AstDB
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/date)=${FECHA})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/time)=${HORA})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/file)=${RECFILE_BASE})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/type)=${D_TMP_TYPE})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/offset)=${OFFSET_MIN})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/repeats)=${REPEATS})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/state)=scheduled)

 ; Llamar a macro que crea los .call (pasa args)
 same => n,NoOp(Llamando a macro-schedule-reminder ...)
 same => n,Macro(schedule-reminder,${NUMERO_ORIGEN},${NEXTID},${FECHA},${HORA},${RECFILE_BASE},${D_TMP_TYPE},${OFFSET_MIN},${REPEATS})
 same => n,Playback(custom-vm-goodbye)
 same => n,Hangup()

 same => n(abort_no_ext),Playback(vm-yourcalledidis)
 same => n,Hangup()
 same => n(end),Hangup()










; -------------------------
; MACRO: schedule reminder (UN SOLO .call programado en EVENT - OFFSET)
; ARG1=NUM_ORIGEN ARG2=ID ARG3=FECHA(AAAAMMDD) ARG4=HORA(HHMM)
; ARG5=RECFILE ARG6=TYPE ARG7=OFFSET_MIN ARG8=REPEATS
; Comportamiento: crea 1 .call con mtime = EVENT - OFFSET
; MaxRetries = REPEATS - 1
; RetryTime = OFFSET * 60 (segundos)
; -------------------------
[macro-schedule-reminder]
exten => s,1,NoOp(Macro schedule-reminder (single .call at EVENT-OFFSET) iniciado: ${ARG1} ${ARG2} ${ARG3} ${ARG4} ${ARG5} ${ARG6} ${ARG7} ${ARG8})
 same => n,Set(YEAR=${ARG3:0:4})
 same => n,Set(MONTH=${ARG3:4:2})
 same => n,Set(DAY=${ARG3:6:2})
 same => n,Set(HH=${ARG4:0:2})
 same => n,Set(MM=${ARG4:2:2})

 ; Validar repeats y offset mínimos sensatos
 same => n,Set(REPEATS=${ARG8})
 same => n,ExecIf($[${REPEATS} < 1]?Set(REPEATS=1))
 same => n,Set(OFFSET_MIN=${ARG7})
 same => n,ExecIf($[${OFFSET_MIN} < 1]?Set(OFFSET_MIN=1))

 ; Inicializar retry params ANTES del branch schedule_now (previene .call con líneas vacías)
 same => n,Set(RETRYTIME_SEC=50)    ; 50  segundos entre reintentos (tú dijiste que lo quieres así)
 same => n,Set(MAXRETRIES=$[ ${REPEATS} - 1 ])
 same => n,ExecIf($[${MAXRETRIES} < 0]?Set(MAXRETRIES=0))
 same => n,Set(WAITTIME=30)

 ; Calcular FIRST_TOUCH de forma robusta y eliminar saltos de línea del output
 same => n,Set(FIRST_TOUCH=${SHELL(/bin/sh -c "start=\$(date -d '${YEAR}-${MONTH}-${DAY} ${HH}:${MM}' +%s 2>/dev/null) && [ -n \"\$start\" ] && date -d \"@\$((start - ${OFFSET_MIN}*60))\" +%Y%m%d%H%M.%S 2>/dev/null | tr -d '\\r\\n'")})
 same => n,NoOp(FIRST_ATTEMPT_TOUCH=${FIRST_TOUCH} OFFSET_MIN=${OFFSET_MIN} REPEATS=${REPEATS} RETRYTIME_SEC=${RETRYTIME_SEC} MAXRETRIES=${MAXRETRIES})

 ; Si primer cálculo falló intentamos sintaxis alternativa (también limpiamos newline)
 same => n,GotoIf($["${FIRST_TOUCH}" != ""]?create_call)
 same => n,Set(FIRST_TOUCH=${SHELL(/bin/sh -c "date -d '${YEAR}-${MONTH}-${DAY} ${HH}:${MM} - ${OFFSET_MIN} minutes' +%Y%m%d%H%M.%S 2>/dev/null | tr -d '\\r\\n'")})
 same => n,NoOp(SECOND_ATTEMPT_TOUCH=${FIRST_TOUCH})
 same => n,GotoIf($["${FIRST_TOUCH}" != ""]?create_call)

 ; Fallback: schedule now (si no pudimos calcular una mtime válida)
 same => n,NoOp(TOUCH_TIME invalid => scheduling immediate)
 same => n,Set(CALLTMP=/tmp/reminder_${ARG2}.call)
 same => n,System(/bin/sh -c "printf 'Channel: Local/${ARG1}@from-internal\nCallerID: \"Recordatorio\" <${ARG1}>\nMaxRetries: ${MAXRETRIES}\nRetryTime: ${RETRYTIME_SEC}\nWaitTime: ${WAITTIME}\nContext: reminders-play\nExtension: s\nPriority: 1\nSetvar: REMINDER_ID=${ARG2}\nSetvar: REMINDER_ORIG=${ARG1}\nSetvar: REMINDER_FILE=${ARG5}\nSetvar: REMINDER_TYPE=${ARG6}\n' > '${CALLTMP}' && chown asterisk:asterisk '${CALLTMP}' && chmod 660 '${CALLTMP}' && mv '${CALLTMP}' /var/spool/asterisk/outgoing/)")
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/first_attempt)=now)
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/state)=scheduled)
 same => n,MacroExit()

 ; Label: crear call normal con FIRST_TOUCH calculado (sin newline)
 same => n(create_call),Set(CALLTMP=/tmp/reminder_${ARG2}.call)
 ; Creamos, ponemos mtime correctamente con touch y movemos en una única línea para evitar condiciones de carrera
 same => n,System(/bin/sh -c "printf 'Channel: Local/${ARG1}@from-internal\nCallerID: \"Recordatorio\" <${ARG1}>\nMaxRetries: ${MAXRETRIES}\nRetryTime: ${RETRYTIME_SEC}\nWaitTime: ${WAITTIME}\nContext: reminders-play\nExtension: s\nPriority: 1\nSetvar: REMINDER_ID=${ARG2}\nSetvar: REMINDER_ORIG=${ARG1}\nSetvar: REMINDER_FILE=${ARG5}\nSetvar: REMINDER_TYPE=${ARG6}\n' > '${CALLTMP}' && touch -t ${FIRST_TOUCH} '${CALLTMP}' 2>/dev/null && chown asterisk:asterisk '${CALLTMP}' && chmod 660 '${CALLTMP}' && mv '${CALLTMP}' /var/spool/asterisk/outgoing/ || (chown asterisk:asterisk '${CALLTMP}' && chmod 660 '${CALLTMP}' && mv '${CALLTMP}' /var/spool/asterisk/outgoing/)")

 same => n,NoOp(.call creado y movido: /var/spool/asterisk/outgoing/reminder_${ARG2}.call time=${FIRST_TOUCH})
 ; Guardar metadatos en AstDB
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/first_attempt)=${FIRST_TOUCH})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/offset)=${OFFSET_MIN})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/repeats)=${REPEATS})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/maxretries)=${MAXRETRIES})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/retrytime)=${RETRYTIME_SEC})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/waittime)=${WAITTIME})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/state)=scheduled)
 same => n,MacroExit()

