[from-internal-custom]
; quien marca *222# aterriza aquí
exten => _*222#,1,Answer()
 same => n,NoOp(Menu *222# (Background example))
 same => n,Background(custom-enter-menu)  ; reproduce audio: "Presione 1 para X, 2 para crear recordatorio..."
 same => n,WaitExten(6)             ; si no pulsa nada, espera 6s para que ingrese DTMF
 same => n,Playback(custom-goodbye)
 same => n,Hangup()

; Handlers (si el usuario pulsa 1 o 2 durante el Background)
exten => 1,1,NoOp(Usuario pulsó 1)
 same => n,Playback(custom/option1-confirm)
 same => n,Hangup()

exten => 2,1,NoOp(Usuario pulsó 2 -> iniciar flow de recordatorio)
 same => n,Playback(custom/option2-confirm)
 same => n,Macro(collect-reminder)   ; llama al macro que ya definiste
 same => n,Hangup()



; -------------------------
; MACRO: collect reminder
; Recoge fecha, hora, tipo, grabación, offset y repeticiones.
; Llama a macro-schedule-reminder con los argumentos:
; ARG1 = NUMERO_ORIGEN, ARG2 = NEXTID, ARG3 = FECHA(AAAAMMDD), ARG4 = HORA(HHMM),
; ARG5 = RECFILE (ruta completa .wav), ARG6 = TYPE
; ARG7 = OFFSET_MINUTES (15|30|1440), ARG8 = REPEATS (entero)
; -------------------------
[macro-collect-reminder]
exten => s,1,NoOp(Macro collect-reminder iniciado)
 same => n,Answer()
 same => n,Set(FECHA_PROMPT=custom-enter-date)
 same => n,Set(FECHA_TRIES=3)
 same => n(read_date),ExecIf($[${ISNULL(${FECHA_PROMPT})}=0]?Playback(${FECHA_PROMPT}):Playback(beep))
 same => n,Playback(beep)
 same => n,Read(FECHA,,8,,${FECHA_TRIES},10)    ; AAAAMMDD
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?read_date)
 same => n,GotoIf($[${LEN(${FECHA})}=8]?date_valid:date_retry)
 same => n(date_retry),Set(FECHA_TRIES=$[${FECHA_TRIES} - 1])
 same => n,GotoIf($[${FECHA_TRIES} > 0]?read_date:date_fail)
 same => n(date_fail),Playback(custom-goodbye)
 same => n,Hangup()
 same => n(date_valid),NoOp(FECHA OK: ${FECHA})

 ; HORA
 same => n,Set(HORA_PROMPT=custom-enter-time)
 same => n,Set(HORA_TRIES=3)
 same => n(read_time),ExecIf($[${ISNULL(${HORA_PROMPT})}=0]?Playback(${HORA_PROMPT}):Playback(beep))
 same => n,Playback(beep)
 same => n,Read(HORA,,4,,${HORA_TRIES},8)       ; HHMM
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?read_time)
 same => n,GotoIf($[${LEN(${HORA})}=4]?time_valid:time_retry)
 same => n(time_retry),Set(HORA_TRIES=$[${HORA_TRIES} - 1])
 same => n,GotoIf($[${HORA_TRIES} > 0]?read_time:time_fail)
 same => n(time_fail),Playback(custom-goodbye)
 same => n,Hangup()
 same => n(time_valid),NoOp(HORA OK: ${HORA})

 ; Origen y NEXTID (igual que tu código original)
 same => n,Set(NUMERO_ORIGEN=${CALLERID(num)})
 same => n,GotoIf($["${NUMERO_ORIGEN}" = ""]?abort_no_ext)
 same => n,Set(NEXTID=${DB(reminders/${NUMERO_ORIGEN}/nextid)})
 same => n,GotoIf($["${NEXTID}" = ""]?setid)
 same => n,Set(NEXTID=$[${NEXTID} + 1])
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/nextid)=${NEXTID})
 same => n,Goto(store)
 same => n(setid),Set(NEXTID=1)
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/nextid)=${NEXTID})
 same => n(store),NoOp(Asignado reminder ID ${NEXTID})

; Tipo (reutilizo tu menu tipo 1..4)
 same => n,Playback(custom-enter-type)    ; "Presione 1 para Cumpleaños, 2 Reunión..."
 same => n,Playback(beep)
 same => n,Read(REM_TYPE,,1,,2,6)         ; lee 1 dígito
 same => n,GotoIf($["${READSTATUS}" = "HANGUP"]?end)
 same => n,GotoIf($["${READSTATUS}" = "TIMEOUT"]?type_no_input)
 ; Validar valor y mapear
 same => n,GotoIf($["${REM_TYPE}" = "1"]?type_birthday)
 same => n,GotoIf($["${REM_TYPE}" = "2"]?type_meeting)
 same => n,GotoIf($["${REM_TYPE}" = "3"]?type_work)
 same => n,GotoIf($["${REM_TYPE}" = "4"]?type_appointment)
 same => n(type_no_input),Playback(custom-goodbye)
 same => n,Hangup()

 same => n(type_birthday),Set(D_TMP_TYPE=birthday)
 same => n,Goto(type_store)
 same => n(type_meeting),Set(D_TMP_TYPE=meeting)
 same => n,Goto(type_store)
 same => n(type_work),Set(D_TMP_TYPE=work)
 same => n,Goto(type_store)
 same => n(type_appointment),Set(D_TMP_TYPE=appointment)
 same => n,Goto(type_store)

 same => n(type_store),Set(D_TMP_TYPE=${D_TMP_TYPE}) ; (opcional reafirmar)


 ; Preparar carpeta grabaciones
 same => n,Set(SOUNDDIR=/var/lib/asterisk/sounds/custom)
 same => n,System(mkdir -p ${SOUNDDIR} >/dev/null 2>&1)
 same => n,System(chown -R asterisk:asterisk ${SOUNDDIR} >/dev/null 2>&1 || true)
 same => n,Set(RECBASE=reminder_${NEXTID})
 same => n,Set(RECFILE_BASE=${RECBASE}.wav)       
 same => n,Set(RECFILE=${SOUNDDIR}/${RECFILE_BASE})

 ; Grabar mensaje
 same => n,Playback(custom-start-recording)
 same => n,Record(${RECFILE},5,120)        ; silencio 5s para terminar, max 120s
 same => n,System(chown asterisk:asterisk "${RECFILE}" >/dev/null 2>&1 || true)
 same => n,System(chmod 640 "${RECFILE}" >/dev/null 2>&1 || true)

 ; Mostrar y confirmar (opcional) - reproduzco lo grabado
 same => n,Playback(custom/${RECBASE})

 ; MENU: seleccionar offset (tiempo antes): 1=15min 2=30min 3=1dia
 same => n,Playback(custom-select-offset)   ; "Seleccione: 1=15 min, 2=30 min, 3=1 dia"
 same => n,Playback(beep)
 same => n,Read(OFFSET_CHOICE,,1,,2,7)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "1"]?offset15)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "2"]?offset30)
 same => n,GotoIf($["${OFFSET_CHOICE}" = "3"]?offset1d)
 same => n,Playback(custom-goodbye)
 same => n,Hangup()
 same => n(offset15),Set(OFFSET_MIN=15)
 same => n,Goto(offset_selected)
 same => n(offset30),Set(OFFSET_MIN=30)
 same => n,Goto(offset_selected)
 same => n(offset1d),Set(OFFSET_MIN=1440)
 same => n(offset_selected),NoOp(Offset seleccionado ${OFFSET_MIN} minutos)

 ; Pedir número de repeticiones (veces del recordatorio). Máx 9 por seguridad
 same => n,Playback(custom-enter-repeats)  ; "Ingrese cuantas veces"
 same => n,Playback(beep)
 same => n,Read(REPEATS,,1,,2,6)
 same => n,GotoIf($["${REPEATS}" = ""]?repeats_fail)
 same => n,GotoIf($[${REPEATS} > 0 & ${REPEATS} <= 9]?repeats_ok:repeats_fail)
 same => n(repeats_fail),Playback(custom-goodbye)
 same => n,Hangup()
 same => n(repeats_ok),NoOp(REPEATS=${REPEATS})

 ; Guardar metadata base en AstDB
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/date)=${FECHA})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/time)=${HORA})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/file)=${RECFILE_BASE})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/type)=${D_TMP_TYPE})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/offset)=${OFFSET_MIN})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/repeats)=${REPEATS})
 same => n,Set(DB(reminders/${NUMERO_ORIGEN}/${NEXTID}/state)=scheduled)

 ; Llamar a macro que crea los .call (pasa args)
 same => n,NoOp(Llamando a macro-schedule-reminder ...)
 same => n,Macro(schedule-reminder,${NUMERO_ORIGEN},${NEXTID},${FECHA},${HORA},${RECFILE_BASE},${D_TMP_TYPE},${OFFSET_MIN},${REPEATS})
 same => n,Playback(custom-vm-goodbye)
 same => n,Hangup()

 same => n(abort_no_ext),Playback(vm-yourcalledidis)
 same => n,Hangup()
 same => n(end),Hangup()










; -------------------------
; MACRO: schedule reminder (UN SOLO .call programado en EVENT - OFFSET)
; ARG1=NUM_ORIGEN ARG2=ID ARG3=FECHA(AAAAMMDD) ARG4=HORA(HHMM)
; ARG5=RECFILE ARG6=TYPE ARG7=OFFSET_MIN ARG8=REPEATS
; Comportamiento: crea 1 .call con mtime = EVENT - OFFSET
; MaxRetries = REPEATS - 1
; RetryTime = OFFSET * 60 (segundos)
; -------------------------
[macro-schedule-reminder]
exten => s,1,NoOp(Macro schedule-reminder (single .call at EVENT-OFFSET) iniciado: ${ARG1} ${ARG2} ${ARG3} ${ARG4} ${ARG5} ${ARG6} ${ARG7} ${ARG8})
 same => n,Set(YEAR=${ARG3:0:4})
 same => n,Set(MONTH=${ARG3:4:2})
 same => n,Set(DAY=${ARG3:6:2})
 same => n,Set(HH=${ARG4:0:2})
 same => n,Set(MM=${ARG4:2:2})

 ; Validar repeats y offset mínimos sensatos
 same => n,Set(REPEATS=${ARG8})
 same => n,ExecIf($[${REPEATS} < 1]?Set(REPEATS=1))
 same => n,Set(OFFSET_MIN=${ARG7})
 same => n,ExecIf($[${OFFSET_MIN} < 1]?Set(OFFSET_MIN=1))

 ; Inicializar retry params ANTES del branch schedule_now (previene .call con líneas vacías)
 same => n,Set(RETRYTIME_SEC=50)    ; 50  segundos entre reintentos (tú dijiste que lo quieres así)
 same => n,Set(MAXRETRIES=$[ ${REPEATS} - 1 ])
 same => n,ExecIf($[${MAXRETRIES} < 0]?Set(MAXRETRIES=0))
 same => n,Set(WAITTIME=30)

 ; Calcular FIRST_TOUCH de forma robusta y eliminar saltos de línea del output
 same => n,Set(FIRST_TOUCH=${SHELL(/bin/sh -c "start=\$(date -d '${YEAR}-${MONTH}-${DAY} ${HH}:${MM}' +%s 2>/dev/null) && [ -n \"\$start\" ] && date -d \"@\$((start - ${OFFSET_MIN}*60))\" +%Y%m%d%H%M.%S 2>/dev/null | tr -d '\\r\\n'")})
 same => n,NoOp(FIRST_ATTEMPT_TOUCH=${FIRST_TOUCH} OFFSET_MIN=${OFFSET_MIN} REPEATS=${REPEATS} RETRYTIME_SEC=${RETRYTIME_SEC} MAXRETRIES=${MAXRETRIES})

 ; Si primer cálculo falló intentamos sintaxis alternativa (también limpiamos newline)
 same => n,GotoIf($["${FIRST_TOUCH}" != ""]?create_call)
 same => n,Set(FIRST_TOUCH=${SHELL(/bin/sh -c "date -d '${YEAR}-${MONTH}-${DAY} ${HH}:${MM} - ${OFFSET_MIN} minutes' +%Y%m%d%H%M.%S 2>/dev/null | tr -d '\\r\\n'")})
 same => n,NoOp(SECOND_ATTEMPT_TOUCH=${FIRST_TOUCH})
 same => n,GotoIf($["${FIRST_TOUCH}" != ""]?create_call)

 ; Fallback: schedule now (si no pudimos calcular una mtime válida)
 same => n,NoOp(TOUCH_TIME invalid => scheduling immediate)
 same => n,Set(CALLTMP=/tmp/reminder_${ARG2}.call)
 same => n,System(/bin/sh -c "printf 'Channel: Local/${ARG1}@from-internal\nCallerID: \"Recordatorio\" <${ARG1}>\nMaxRetries: ${MAXRETRIES}\nRetryTime: ${RETRYTIME_SEC}\nWaitTime: ${WAITTIME}\nContext: reminders-play\nExtension: s\nPriority: 1\nSetvar: REMINDER_ID=${ARG2}\nSetvar: REMINDER_ORIG=${ARG1}\nSetvar: REMINDER_FILE=${ARG5}\nSetvar: REMINDER_TYPE=${ARG6}\n' > '${CALLTMP}' && chown asterisk:asterisk '${CALLTMP}' && chmod 660 '${CALLTMP}' && mv '${CALLTMP}' /var/spool/asterisk/outgoing/)")
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/first_attempt)=now)
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/state)=scheduled)
 same => n,MacroExit()

 ; Label: crear call normal con FIRST_TOUCH calculado (sin newline)
 same => n(create_call),Set(CALLTMP=/tmp/reminder_${ARG2}.call)
 ; Creamos, ponemos mtime correctamente con touch y movemos en una única línea para evitar condiciones de carrera
 same => n,System(/bin/sh -c "printf 'Channel: Local/${ARG1}@from-internal\nCallerID: \"Recordatorio\" <${ARG1}>\nMaxRetries: ${MAXRETRIES}\nRetryTime: ${RETRYTIME_SEC}\nWaitTime: ${WAITTIME}\nContext: reminders-play\nExtension: s\nPriority: 1\nSetvar: REMINDER_ID=${ARG2}\nSetvar: REMINDER_ORIG=${ARG1}\nSetvar: REMINDER_FILE=${ARG5}\nSetvar: REMINDER_TYPE=${ARG6}\n' > '${CALLTMP}' && touch -t ${FIRST_TOUCH} '${CALLTMP}' 2>/dev/null && chown asterisk:asterisk '${CALLTMP}' && chmod 660 '${CALLTMP}' && mv '${CALLTMP}' /var/spool/asterisk/outgoing/ || (chown asterisk:asterisk '${CALLTMP}' && chmod 660 '${CALLTMP}' && mv '${CALLTMP}' /var/spool/asterisk/outgoing/)")

 same => n,NoOp(.call creado y movido: /var/spool/asterisk/outgoing/reminder_${ARG2}.call time=${FIRST_TOUCH})
 ; Guardar metadatos en AstDB
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/first_attempt)=${FIRST_TOUCH})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/offset)=${OFFSET_MIN})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/repeats)=${REPEATS})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/maxretries)=${MAXRETRIES})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/retrytime)=${RETRYTIME_SEC})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/waittime)=${WAITTIME})
 same => n,Set(DB(reminders/${ARG1}/${ARG2}/state)=scheduled)
 same => n,MacroExit()

